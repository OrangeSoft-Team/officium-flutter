// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides

part of 'factoriaValorErroneo.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more informations: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
class _$ValorErroneoTearOff {
  const _$ValorErroneoTearOff();

  ExcedeLongitudMaxima<T> excedeLongitudMaxima<T>(
      {required T valorErroneo, required int max}) {
    return ExcedeLongitudMaxima<T>(
      valorErroneo: valorErroneo,
      max: max,
    );
  }

  EmailInvalido<T> emailInvalido<T>({required T valorErroneo}) {
    return EmailInvalido<T>(
      valorErroneo: valorErroneo,
    );
  }

  ContrasenaCorta<T> contrasenaCorta<T>({required T valorErroneo}) {
    return ContrasenaCorta<T>(
      valorErroneo: valorErroneo,
    );
  }

  CiudadInvalida<T> ciudadInvalida<T>({required T valorErroneo}) {
    return CiudadInvalida<T>(
      valorErroneo: valorErroneo,
    );
  }

  FechaInvalida<T> fechaInvalida<T>({required T valorErroneo}) {
    return FechaInvalida<T>(
      valorErroneo: valorErroneo,
    );
  }

  CargoLongitudInvalida<T> cargoLongitudInvalida<T>(
      {required T valorErroneo, required int min, required int max}) {
    return CargoLongitudInvalida<T>(
      valorErroneo: valorErroneo,
      min: min,
      max: max,
    );
  }

  SueldoInvalida<T> sueldoInvalido<T>(
      {required T valorErroneo, required double max}) {
    return SueldoInvalida<T>(
      valorErroneo: valorErroneo,
      max: max,
    );
  }

  FechaNula<T> fechaNula<T>({required T fechaErronea}) {
    return FechaNula<T>(
      fechaErronea: fechaErronea,
    );
  }
}

/// @nodoc
const $ValorErroneo = _$ValorErroneoTearOff();

/// @nodoc
mixin _$ValorErroneo<T> {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(T valorErroneo, int max) excedeLongitudMaxima,
    required TResult Function(T valorErroneo) emailInvalido,
    required TResult Function(T valorErroneo) contrasenaCorta,
    required TResult Function(T valorErroneo) ciudadInvalida,
    required TResult Function(T valorErroneo) fechaInvalida,
    required TResult Function(T valorErroneo, int min, int max)
        cargoLongitudInvalida,
    required TResult Function(T valorErroneo, double max) sueldoInvalido,
    required TResult Function(T fechaErronea) fechaNula,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(T valorErroneo, int max)? excedeLongitudMaxima,
    TResult Function(T valorErroneo)? emailInvalido,
    TResult Function(T valorErroneo)? contrasenaCorta,
    TResult Function(T valorErroneo)? ciudadInvalida,
    TResult Function(T valorErroneo)? fechaInvalida,
    TResult Function(T valorErroneo, int min, int max)? cargoLongitudInvalida,
    TResult Function(T valorErroneo, double max)? sueldoInvalido,
    TResult Function(T fechaErronea)? fechaNula,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ExcedeLongitudMaxima<T> value)
        excedeLongitudMaxima,
    required TResult Function(EmailInvalido<T> value) emailInvalido,
    required TResult Function(ContrasenaCorta<T> value) contrasenaCorta,
    required TResult Function(CiudadInvalida<T> value) ciudadInvalida,
    required TResult Function(FechaInvalida<T> value) fechaInvalida,
    required TResult Function(CargoLongitudInvalida<T> value)
        cargoLongitudInvalida,
    required TResult Function(SueldoInvalida<T> value) sueldoInvalido,
    required TResult Function(FechaNula<T> value) fechaNula,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ExcedeLongitudMaxima<T> value)? excedeLongitudMaxima,
    TResult Function(EmailInvalido<T> value)? emailInvalido,
    TResult Function(ContrasenaCorta<T> value)? contrasenaCorta,
    TResult Function(CiudadInvalida<T> value)? ciudadInvalida,
    TResult Function(FechaInvalida<T> value)? fechaInvalida,
    TResult Function(CargoLongitudInvalida<T> value)? cargoLongitudInvalida,
    TResult Function(SueldoInvalida<T> value)? sueldoInvalido,
    TResult Function(FechaNula<T> value)? fechaNula,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ValorErroneoCopyWith<T, $Res> {
  factory $ValorErroneoCopyWith(
          ValorErroneo<T> value, $Res Function(ValorErroneo<T>) then) =
      _$ValorErroneoCopyWithImpl<T, $Res>;
}

/// @nodoc
class _$ValorErroneoCopyWithImpl<T, $Res>
    implements $ValorErroneoCopyWith<T, $Res> {
  _$ValorErroneoCopyWithImpl(this._value, this._then);

  final ValorErroneo<T> _value;
  // ignore: unused_field
  final $Res Function(ValorErroneo<T>) _then;
}

/// @nodoc
abstract class $ExcedeLongitudMaximaCopyWith<T, $Res> {
  factory $ExcedeLongitudMaximaCopyWith(ExcedeLongitudMaxima<T> value,
          $Res Function(ExcedeLongitudMaxima<T>) then) =
      _$ExcedeLongitudMaximaCopyWithImpl<T, $Res>;
  $Res call({T valorErroneo, int max});
}

/// @nodoc
class _$ExcedeLongitudMaximaCopyWithImpl<T, $Res>
    extends _$ValorErroneoCopyWithImpl<T, $Res>
    implements $ExcedeLongitudMaximaCopyWith<T, $Res> {
  _$ExcedeLongitudMaximaCopyWithImpl(ExcedeLongitudMaxima<T> _value,
      $Res Function(ExcedeLongitudMaxima<T>) _then)
      : super(_value, (v) => _then(v as ExcedeLongitudMaxima<T>));

  @override
  ExcedeLongitudMaxima<T> get _value => super._value as ExcedeLongitudMaxima<T>;

  @override
  $Res call({
    Object? valorErroneo = freezed,
    Object? max = freezed,
  }) {
    return _then(ExcedeLongitudMaxima<T>(
      valorErroneo: valorErroneo == freezed
          ? _value.valorErroneo
          : valorErroneo // ignore: cast_nullable_to_non_nullable
              as T,
      max: max == freezed
          ? _value.max
          : max // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$ExcedeLongitudMaxima<T> implements ExcedeLongitudMaxima<T> {
  const _$ExcedeLongitudMaxima({required this.valorErroneo, required this.max});

  @override
  final T valorErroneo;
  @override
  final int max;

  @override
  String toString() {
    return 'ValorErroneo<$T>.excedeLongitudMaxima(valorErroneo: $valorErroneo, max: $max)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is ExcedeLongitudMaxima<T> &&
            (identical(other.valorErroneo, valorErroneo) ||
                const DeepCollectionEquality()
                    .equals(other.valorErroneo, valorErroneo)) &&
            (identical(other.max, max) ||
                const DeepCollectionEquality().equals(other.max, max)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(valorErroneo) ^
      const DeepCollectionEquality().hash(max);

  @JsonKey(ignore: true)
  @override
  $ExcedeLongitudMaximaCopyWith<T, ExcedeLongitudMaxima<T>> get copyWith =>
      _$ExcedeLongitudMaximaCopyWithImpl<T, ExcedeLongitudMaxima<T>>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(T valorErroneo, int max) excedeLongitudMaxima,
    required TResult Function(T valorErroneo) emailInvalido,
    required TResult Function(T valorErroneo) contrasenaCorta,
    required TResult Function(T valorErroneo) ciudadInvalida,
    required TResult Function(T valorErroneo) fechaInvalida,
    required TResult Function(T valorErroneo, int min, int max)
        cargoLongitudInvalida,
    required TResult Function(T valorErroneo, double max) sueldoInvalido,
    required TResult Function(T fechaErronea) fechaNula,
  }) {
    return excedeLongitudMaxima(valorErroneo, max);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(T valorErroneo, int max)? excedeLongitudMaxima,
    TResult Function(T valorErroneo)? emailInvalido,
    TResult Function(T valorErroneo)? contrasenaCorta,
    TResult Function(T valorErroneo)? ciudadInvalida,
    TResult Function(T valorErroneo)? fechaInvalida,
    TResult Function(T valorErroneo, int min, int max)? cargoLongitudInvalida,
    TResult Function(T valorErroneo, double max)? sueldoInvalido,
    TResult Function(T fechaErronea)? fechaNula,
    required TResult orElse(),
  }) {
    if (excedeLongitudMaxima != null) {
      return excedeLongitudMaxima(valorErroneo, max);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ExcedeLongitudMaxima<T> value)
        excedeLongitudMaxima,
    required TResult Function(EmailInvalido<T> value) emailInvalido,
    required TResult Function(ContrasenaCorta<T> value) contrasenaCorta,
    required TResult Function(CiudadInvalida<T> value) ciudadInvalida,
    required TResult Function(FechaInvalida<T> value) fechaInvalida,
    required TResult Function(CargoLongitudInvalida<T> value)
        cargoLongitudInvalida,
    required TResult Function(SueldoInvalida<T> value) sueldoInvalido,
    required TResult Function(FechaNula<T> value) fechaNula,
  }) {
    return excedeLongitudMaxima(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ExcedeLongitudMaxima<T> value)? excedeLongitudMaxima,
    TResult Function(EmailInvalido<T> value)? emailInvalido,
    TResult Function(ContrasenaCorta<T> value)? contrasenaCorta,
    TResult Function(CiudadInvalida<T> value)? ciudadInvalida,
    TResult Function(FechaInvalida<T> value)? fechaInvalida,
    TResult Function(CargoLongitudInvalida<T> value)? cargoLongitudInvalida,
    TResult Function(SueldoInvalida<T> value)? sueldoInvalido,
    TResult Function(FechaNula<T> value)? fechaNula,
    required TResult orElse(),
  }) {
    if (excedeLongitudMaxima != null) {
      return excedeLongitudMaxima(this);
    }
    return orElse();
  }
}

abstract class ExcedeLongitudMaxima<T> implements ValorErroneo<T> {
  const factory ExcedeLongitudMaxima(
      {required T valorErroneo, required int max}) = _$ExcedeLongitudMaxima<T>;

  T get valorErroneo => throw _privateConstructorUsedError;
  int get max => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ExcedeLongitudMaximaCopyWith<T, ExcedeLongitudMaxima<T>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $EmailInvalidoCopyWith<T, $Res> {
  factory $EmailInvalidoCopyWith(
          EmailInvalido<T> value, $Res Function(EmailInvalido<T>) then) =
      _$EmailInvalidoCopyWithImpl<T, $Res>;
  $Res call({T valorErroneo});
}

/// @nodoc
class _$EmailInvalidoCopyWithImpl<T, $Res>
    extends _$ValorErroneoCopyWithImpl<T, $Res>
    implements $EmailInvalidoCopyWith<T, $Res> {
  _$EmailInvalidoCopyWithImpl(
      EmailInvalido<T> _value, $Res Function(EmailInvalido<T>) _then)
      : super(_value, (v) => _then(v as EmailInvalido<T>));

  @override
  EmailInvalido<T> get _value => super._value as EmailInvalido<T>;

  @override
  $Res call({
    Object? valorErroneo = freezed,
  }) {
    return _then(EmailInvalido<T>(
      valorErroneo: valorErroneo == freezed
          ? _value.valorErroneo
          : valorErroneo // ignore: cast_nullable_to_non_nullable
              as T,
    ));
  }
}

/// @nodoc

class _$EmailInvalido<T> implements EmailInvalido<T> {
  const _$EmailInvalido({required this.valorErroneo});

  @override
  final T valorErroneo;

  @override
  String toString() {
    return 'ValorErroneo<$T>.emailInvalido(valorErroneo: $valorErroneo)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is EmailInvalido<T> &&
            (identical(other.valorErroneo, valorErroneo) ||
                const DeepCollectionEquality()
                    .equals(other.valorErroneo, valorErroneo)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(valorErroneo);

  @JsonKey(ignore: true)
  @override
  $EmailInvalidoCopyWith<T, EmailInvalido<T>> get copyWith =>
      _$EmailInvalidoCopyWithImpl<T, EmailInvalido<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(T valorErroneo, int max) excedeLongitudMaxima,
    required TResult Function(T valorErroneo) emailInvalido,
    required TResult Function(T valorErroneo) contrasenaCorta,
    required TResult Function(T valorErroneo) ciudadInvalida,
    required TResult Function(T valorErroneo) fechaInvalida,
    required TResult Function(T valorErroneo, int min, int max)
        cargoLongitudInvalida,
    required TResult Function(T valorErroneo, double max) sueldoInvalido,
    required TResult Function(T fechaErronea) fechaNula,
  }) {
    return emailInvalido(valorErroneo);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(T valorErroneo, int max)? excedeLongitudMaxima,
    TResult Function(T valorErroneo)? emailInvalido,
    TResult Function(T valorErroneo)? contrasenaCorta,
    TResult Function(T valorErroneo)? ciudadInvalida,
    TResult Function(T valorErroneo)? fechaInvalida,
    TResult Function(T valorErroneo, int min, int max)? cargoLongitudInvalida,
    TResult Function(T valorErroneo, double max)? sueldoInvalido,
    TResult Function(T fechaErronea)? fechaNula,
    required TResult orElse(),
  }) {
    if (emailInvalido != null) {
      return emailInvalido(valorErroneo);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ExcedeLongitudMaxima<T> value)
        excedeLongitudMaxima,
    required TResult Function(EmailInvalido<T> value) emailInvalido,
    required TResult Function(ContrasenaCorta<T> value) contrasenaCorta,
    required TResult Function(CiudadInvalida<T> value) ciudadInvalida,
    required TResult Function(FechaInvalida<T> value) fechaInvalida,
    required TResult Function(CargoLongitudInvalida<T> value)
        cargoLongitudInvalida,
    required TResult Function(SueldoInvalida<T> value) sueldoInvalido,
    required TResult Function(FechaNula<T> value) fechaNula,
  }) {
    return emailInvalido(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ExcedeLongitudMaxima<T> value)? excedeLongitudMaxima,
    TResult Function(EmailInvalido<T> value)? emailInvalido,
    TResult Function(ContrasenaCorta<T> value)? contrasenaCorta,
    TResult Function(CiudadInvalida<T> value)? ciudadInvalida,
    TResult Function(FechaInvalida<T> value)? fechaInvalida,
    TResult Function(CargoLongitudInvalida<T> value)? cargoLongitudInvalida,
    TResult Function(SueldoInvalida<T> value)? sueldoInvalido,
    TResult Function(FechaNula<T> value)? fechaNula,
    required TResult orElse(),
  }) {
    if (emailInvalido != null) {
      return emailInvalido(this);
    }
    return orElse();
  }
}

abstract class EmailInvalido<T> implements ValorErroneo<T> {
  const factory EmailInvalido({required T valorErroneo}) = _$EmailInvalido<T>;

  T get valorErroneo => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $EmailInvalidoCopyWith<T, EmailInvalido<T>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ContrasenaCortaCopyWith<T, $Res> {
  factory $ContrasenaCortaCopyWith(
          ContrasenaCorta<T> value, $Res Function(ContrasenaCorta<T>) then) =
      _$ContrasenaCortaCopyWithImpl<T, $Res>;
  $Res call({T valorErroneo});
}

/// @nodoc
class _$ContrasenaCortaCopyWithImpl<T, $Res>
    extends _$ValorErroneoCopyWithImpl<T, $Res>
    implements $ContrasenaCortaCopyWith<T, $Res> {
  _$ContrasenaCortaCopyWithImpl(
      ContrasenaCorta<T> _value, $Res Function(ContrasenaCorta<T>) _then)
      : super(_value, (v) => _then(v as ContrasenaCorta<T>));

  @override
  ContrasenaCorta<T> get _value => super._value as ContrasenaCorta<T>;

  @override
  $Res call({
    Object? valorErroneo = freezed,
  }) {
    return _then(ContrasenaCorta<T>(
      valorErroneo: valorErroneo == freezed
          ? _value.valorErroneo
          : valorErroneo // ignore: cast_nullable_to_non_nullable
              as T,
    ));
  }
}

/// @nodoc

class _$ContrasenaCorta<T> implements ContrasenaCorta<T> {
  const _$ContrasenaCorta({required this.valorErroneo});

  @override
  final T valorErroneo;

  @override
  String toString() {
    return 'ValorErroneo<$T>.contrasenaCorta(valorErroneo: $valorErroneo)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is ContrasenaCorta<T> &&
            (identical(other.valorErroneo, valorErroneo) ||
                const DeepCollectionEquality()
                    .equals(other.valorErroneo, valorErroneo)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(valorErroneo);

  @JsonKey(ignore: true)
  @override
  $ContrasenaCortaCopyWith<T, ContrasenaCorta<T>> get copyWith =>
      _$ContrasenaCortaCopyWithImpl<T, ContrasenaCorta<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(T valorErroneo, int max) excedeLongitudMaxima,
    required TResult Function(T valorErroneo) emailInvalido,
    required TResult Function(T valorErroneo) contrasenaCorta,
    required TResult Function(T valorErroneo) ciudadInvalida,
    required TResult Function(T valorErroneo) fechaInvalida,
    required TResult Function(T valorErroneo, int min, int max)
        cargoLongitudInvalida,
    required TResult Function(T valorErroneo, double max) sueldoInvalido,
    required TResult Function(T fechaErronea) fechaNula,
  }) {
    return contrasenaCorta(valorErroneo);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(T valorErroneo, int max)? excedeLongitudMaxima,
    TResult Function(T valorErroneo)? emailInvalido,
    TResult Function(T valorErroneo)? contrasenaCorta,
    TResult Function(T valorErroneo)? ciudadInvalida,
    TResult Function(T valorErroneo)? fechaInvalida,
    TResult Function(T valorErroneo, int min, int max)? cargoLongitudInvalida,
    TResult Function(T valorErroneo, double max)? sueldoInvalido,
    TResult Function(T fechaErronea)? fechaNula,
    required TResult orElse(),
  }) {
    if (contrasenaCorta != null) {
      return contrasenaCorta(valorErroneo);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ExcedeLongitudMaxima<T> value)
        excedeLongitudMaxima,
    required TResult Function(EmailInvalido<T> value) emailInvalido,
    required TResult Function(ContrasenaCorta<T> value) contrasenaCorta,
    required TResult Function(CiudadInvalida<T> value) ciudadInvalida,
    required TResult Function(FechaInvalida<T> value) fechaInvalida,
    required TResult Function(CargoLongitudInvalida<T> value)
        cargoLongitudInvalida,
    required TResult Function(SueldoInvalida<T> value) sueldoInvalido,
    required TResult Function(FechaNula<T> value) fechaNula,
  }) {
    return contrasenaCorta(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ExcedeLongitudMaxima<T> value)? excedeLongitudMaxima,
    TResult Function(EmailInvalido<T> value)? emailInvalido,
    TResult Function(ContrasenaCorta<T> value)? contrasenaCorta,
    TResult Function(CiudadInvalida<T> value)? ciudadInvalida,
    TResult Function(FechaInvalida<T> value)? fechaInvalida,
    TResult Function(CargoLongitudInvalida<T> value)? cargoLongitudInvalida,
    TResult Function(SueldoInvalida<T> value)? sueldoInvalido,
    TResult Function(FechaNula<T> value)? fechaNula,
    required TResult orElse(),
  }) {
    if (contrasenaCorta != null) {
      return contrasenaCorta(this);
    }
    return orElse();
  }
}

abstract class ContrasenaCorta<T> implements ValorErroneo<T> {
  const factory ContrasenaCorta({required T valorErroneo}) =
      _$ContrasenaCorta<T>;

  T get valorErroneo => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ContrasenaCortaCopyWith<T, ContrasenaCorta<T>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CiudadInvalidaCopyWith<T, $Res> {
  factory $CiudadInvalidaCopyWith(
          CiudadInvalida<T> value, $Res Function(CiudadInvalida<T>) then) =
      _$CiudadInvalidaCopyWithImpl<T, $Res>;
  $Res call({T valorErroneo});
}

/// @nodoc
class _$CiudadInvalidaCopyWithImpl<T, $Res>
    extends _$ValorErroneoCopyWithImpl<T, $Res>
    implements $CiudadInvalidaCopyWith<T, $Res> {
  _$CiudadInvalidaCopyWithImpl(
      CiudadInvalida<T> _value, $Res Function(CiudadInvalida<T>) _then)
      : super(_value, (v) => _then(v as CiudadInvalida<T>));

  @override
  CiudadInvalida<T> get _value => super._value as CiudadInvalida<T>;

  @override
  $Res call({
    Object? valorErroneo = freezed,
  }) {
    return _then(CiudadInvalida<T>(
      valorErroneo: valorErroneo == freezed
          ? _value.valorErroneo
          : valorErroneo // ignore: cast_nullable_to_non_nullable
              as T,
    ));
  }
}

/// @nodoc

class _$CiudadInvalida<T> implements CiudadInvalida<T> {
  const _$CiudadInvalida({required this.valorErroneo});

  @override
  final T valorErroneo;

  @override
  String toString() {
    return 'ValorErroneo<$T>.ciudadInvalida(valorErroneo: $valorErroneo)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is CiudadInvalida<T> &&
            (identical(other.valorErroneo, valorErroneo) ||
                const DeepCollectionEquality()
                    .equals(other.valorErroneo, valorErroneo)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(valorErroneo);

  @JsonKey(ignore: true)
  @override
  $CiudadInvalidaCopyWith<T, CiudadInvalida<T>> get copyWith =>
      _$CiudadInvalidaCopyWithImpl<T, CiudadInvalida<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(T valorErroneo, int max) excedeLongitudMaxima,
    required TResult Function(T valorErroneo) emailInvalido,
    required TResult Function(T valorErroneo) contrasenaCorta,
    required TResult Function(T valorErroneo) ciudadInvalida,
    required TResult Function(T valorErroneo) fechaInvalida,
    required TResult Function(T valorErroneo, int min, int max)
        cargoLongitudInvalida,
    required TResult Function(T valorErroneo, double max) sueldoInvalido,
    required TResult Function(T fechaErronea) fechaNula,
  }) {
    return ciudadInvalida(valorErroneo);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(T valorErroneo, int max)? excedeLongitudMaxima,
    TResult Function(T valorErroneo)? emailInvalido,
    TResult Function(T valorErroneo)? contrasenaCorta,
    TResult Function(T valorErroneo)? ciudadInvalida,
    TResult Function(T valorErroneo)? fechaInvalida,
    TResult Function(T valorErroneo, int min, int max)? cargoLongitudInvalida,
    TResult Function(T valorErroneo, double max)? sueldoInvalido,
    TResult Function(T fechaErronea)? fechaNula,
    required TResult orElse(),
  }) {
    if (ciudadInvalida != null) {
      return ciudadInvalida(valorErroneo);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ExcedeLongitudMaxima<T> value)
        excedeLongitudMaxima,
    required TResult Function(EmailInvalido<T> value) emailInvalido,
    required TResult Function(ContrasenaCorta<T> value) contrasenaCorta,
    required TResult Function(CiudadInvalida<T> value) ciudadInvalida,
    required TResult Function(FechaInvalida<T> value) fechaInvalida,
    required TResult Function(CargoLongitudInvalida<T> value)
        cargoLongitudInvalida,
    required TResult Function(SueldoInvalida<T> value) sueldoInvalido,
    required TResult Function(FechaNula<T> value) fechaNula,
  }) {
    return ciudadInvalida(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ExcedeLongitudMaxima<T> value)? excedeLongitudMaxima,
    TResult Function(EmailInvalido<T> value)? emailInvalido,
    TResult Function(ContrasenaCorta<T> value)? contrasenaCorta,
    TResult Function(CiudadInvalida<T> value)? ciudadInvalida,
    TResult Function(FechaInvalida<T> value)? fechaInvalida,
    TResult Function(CargoLongitudInvalida<T> value)? cargoLongitudInvalida,
    TResult Function(SueldoInvalida<T> value)? sueldoInvalido,
    TResult Function(FechaNula<T> value)? fechaNula,
    required TResult orElse(),
  }) {
    if (ciudadInvalida != null) {
      return ciudadInvalida(this);
    }
    return orElse();
  }
}

abstract class CiudadInvalida<T> implements ValorErroneo<T> {
  const factory CiudadInvalida({required T valorErroneo}) = _$CiudadInvalida<T>;

  T get valorErroneo => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $CiudadInvalidaCopyWith<T, CiudadInvalida<T>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $FechaInvalidaCopyWith<T, $Res> {
  factory $FechaInvalidaCopyWith(
          FechaInvalida<T> value, $Res Function(FechaInvalida<T>) then) =
      _$FechaInvalidaCopyWithImpl<T, $Res>;
  $Res call({T valorErroneo});
}

/// @nodoc
class _$FechaInvalidaCopyWithImpl<T, $Res>
    extends _$ValorErroneoCopyWithImpl<T, $Res>
    implements $FechaInvalidaCopyWith<T, $Res> {
  _$FechaInvalidaCopyWithImpl(
      FechaInvalida<T> _value, $Res Function(FechaInvalida<T>) _then)
      : super(_value, (v) => _then(v as FechaInvalida<T>));

  @override
  FechaInvalida<T> get _value => super._value as FechaInvalida<T>;

  @override
  $Res call({
    Object? valorErroneo = freezed,
  }) {
    return _then(FechaInvalida<T>(
      valorErroneo: valorErroneo == freezed
          ? _value.valorErroneo
          : valorErroneo // ignore: cast_nullable_to_non_nullable
              as T,
    ));
  }
}

/// @nodoc

class _$FechaInvalida<T> implements FechaInvalida<T> {
  const _$FechaInvalida({required this.valorErroneo});

  @override
  final T valorErroneo;

  @override
  String toString() {
    return 'ValorErroneo<$T>.fechaInvalida(valorErroneo: $valorErroneo)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is FechaInvalida<T> &&
            (identical(other.valorErroneo, valorErroneo) ||
                const DeepCollectionEquality()
                    .equals(other.valorErroneo, valorErroneo)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(valorErroneo);

  @JsonKey(ignore: true)
  @override
  $FechaInvalidaCopyWith<T, FechaInvalida<T>> get copyWith =>
      _$FechaInvalidaCopyWithImpl<T, FechaInvalida<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(T valorErroneo, int max) excedeLongitudMaxima,
    required TResult Function(T valorErroneo) emailInvalido,
    required TResult Function(T valorErroneo) contrasenaCorta,
    required TResult Function(T valorErroneo) ciudadInvalida,
    required TResult Function(T valorErroneo) fechaInvalida,
    required TResult Function(T valorErroneo, int min, int max)
        cargoLongitudInvalida,
    required TResult Function(T valorErroneo, double max) sueldoInvalido,
    required TResult Function(T fechaErronea) fechaNula,
  }) {
    return fechaInvalida(valorErroneo);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(T valorErroneo, int max)? excedeLongitudMaxima,
    TResult Function(T valorErroneo)? emailInvalido,
    TResult Function(T valorErroneo)? contrasenaCorta,
    TResult Function(T valorErroneo)? ciudadInvalida,
    TResult Function(T valorErroneo)? fechaInvalida,
    TResult Function(T valorErroneo, int min, int max)? cargoLongitudInvalida,
    TResult Function(T valorErroneo, double max)? sueldoInvalido,
    TResult Function(T fechaErronea)? fechaNula,
    required TResult orElse(),
  }) {
    if (fechaInvalida != null) {
      return fechaInvalida(valorErroneo);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ExcedeLongitudMaxima<T> value)
        excedeLongitudMaxima,
    required TResult Function(EmailInvalido<T> value) emailInvalido,
    required TResult Function(ContrasenaCorta<T> value) contrasenaCorta,
    required TResult Function(CiudadInvalida<T> value) ciudadInvalida,
    required TResult Function(FechaInvalida<T> value) fechaInvalida,
    required TResult Function(CargoLongitudInvalida<T> value)
        cargoLongitudInvalida,
    required TResult Function(SueldoInvalida<T> value) sueldoInvalido,
    required TResult Function(FechaNula<T> value) fechaNula,
  }) {
    return fechaInvalida(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ExcedeLongitudMaxima<T> value)? excedeLongitudMaxima,
    TResult Function(EmailInvalido<T> value)? emailInvalido,
    TResult Function(ContrasenaCorta<T> value)? contrasenaCorta,
    TResult Function(CiudadInvalida<T> value)? ciudadInvalida,
    TResult Function(FechaInvalida<T> value)? fechaInvalida,
    TResult Function(CargoLongitudInvalida<T> value)? cargoLongitudInvalida,
    TResult Function(SueldoInvalida<T> value)? sueldoInvalido,
    TResult Function(FechaNula<T> value)? fechaNula,
    required TResult orElse(),
  }) {
    if (fechaInvalida != null) {
      return fechaInvalida(this);
    }
    return orElse();
  }
}

abstract class FechaInvalida<T> implements ValorErroneo<T> {
  const factory FechaInvalida({required T valorErroneo}) = _$FechaInvalida<T>;

  T get valorErroneo => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $FechaInvalidaCopyWith<T, FechaInvalida<T>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CargoLongitudInvalidaCopyWith<T, $Res> {
  factory $CargoLongitudInvalidaCopyWith(CargoLongitudInvalida<T> value,
          $Res Function(CargoLongitudInvalida<T>) then) =
      _$CargoLongitudInvalidaCopyWithImpl<T, $Res>;
  $Res call({T valorErroneo, int min, int max});
}

/// @nodoc
class _$CargoLongitudInvalidaCopyWithImpl<T, $Res>
    extends _$ValorErroneoCopyWithImpl<T, $Res>
    implements $CargoLongitudInvalidaCopyWith<T, $Res> {
  _$CargoLongitudInvalidaCopyWithImpl(CargoLongitudInvalida<T> _value,
      $Res Function(CargoLongitudInvalida<T>) _then)
      : super(_value, (v) => _then(v as CargoLongitudInvalida<T>));

  @override
  CargoLongitudInvalida<T> get _value =>
      super._value as CargoLongitudInvalida<T>;

  @override
  $Res call({
    Object? valorErroneo = freezed,
    Object? min = freezed,
    Object? max = freezed,
  }) {
    return _then(CargoLongitudInvalida<T>(
      valorErroneo: valorErroneo == freezed
          ? _value.valorErroneo
          : valorErroneo // ignore: cast_nullable_to_non_nullable
              as T,
      min: min == freezed
          ? _value.min
          : min // ignore: cast_nullable_to_non_nullable
              as int,
      max: max == freezed
          ? _value.max
          : max // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$CargoLongitudInvalida<T> implements CargoLongitudInvalida<T> {
  const _$CargoLongitudInvalida(
      {required this.valorErroneo, required this.min, required this.max});

  @override
  final T valorErroneo;
  @override
  final int min;
  @override
  final int max;

  @override
  String toString() {
    return 'ValorErroneo<$T>.cargoLongitudInvalida(valorErroneo: $valorErroneo, min: $min, max: $max)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is CargoLongitudInvalida<T> &&
            (identical(other.valorErroneo, valorErroneo) ||
                const DeepCollectionEquality()
                    .equals(other.valorErroneo, valorErroneo)) &&
            (identical(other.min, min) ||
                const DeepCollectionEquality().equals(other.min, min)) &&
            (identical(other.max, max) ||
                const DeepCollectionEquality().equals(other.max, max)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(valorErroneo) ^
      const DeepCollectionEquality().hash(min) ^
      const DeepCollectionEquality().hash(max);

  @JsonKey(ignore: true)
  @override
  $CargoLongitudInvalidaCopyWith<T, CargoLongitudInvalida<T>> get copyWith =>
      _$CargoLongitudInvalidaCopyWithImpl<T, CargoLongitudInvalida<T>>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(T valorErroneo, int max) excedeLongitudMaxima,
    required TResult Function(T valorErroneo) emailInvalido,
    required TResult Function(T valorErroneo) contrasenaCorta,
    required TResult Function(T valorErroneo) ciudadInvalida,
    required TResult Function(T valorErroneo) fechaInvalida,
    required TResult Function(T valorErroneo, int min, int max)
        cargoLongitudInvalida,
    required TResult Function(T valorErroneo, double max) sueldoInvalido,
    required TResult Function(T fechaErronea) fechaNula,
  }) {
    return cargoLongitudInvalida(valorErroneo, min, max);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(T valorErroneo, int max)? excedeLongitudMaxima,
    TResult Function(T valorErroneo)? emailInvalido,
    TResult Function(T valorErroneo)? contrasenaCorta,
    TResult Function(T valorErroneo)? ciudadInvalida,
    TResult Function(T valorErroneo)? fechaInvalida,
    TResult Function(T valorErroneo, int min, int max)? cargoLongitudInvalida,
    TResult Function(T valorErroneo, double max)? sueldoInvalido,
    TResult Function(T fechaErronea)? fechaNula,
    required TResult orElse(),
  }) {
    if (cargoLongitudInvalida != null) {
      return cargoLongitudInvalida(valorErroneo, min, max);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ExcedeLongitudMaxima<T> value)
        excedeLongitudMaxima,
    required TResult Function(EmailInvalido<T> value) emailInvalido,
    required TResult Function(ContrasenaCorta<T> value) contrasenaCorta,
    required TResult Function(CiudadInvalida<T> value) ciudadInvalida,
    required TResult Function(FechaInvalida<T> value) fechaInvalida,
    required TResult Function(CargoLongitudInvalida<T> value)
        cargoLongitudInvalida,
    required TResult Function(SueldoInvalida<T> value) sueldoInvalido,
    required TResult Function(FechaNula<T> value) fechaNula,
  }) {
    return cargoLongitudInvalida(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ExcedeLongitudMaxima<T> value)? excedeLongitudMaxima,
    TResult Function(EmailInvalido<T> value)? emailInvalido,
    TResult Function(ContrasenaCorta<T> value)? contrasenaCorta,
    TResult Function(CiudadInvalida<T> value)? ciudadInvalida,
    TResult Function(FechaInvalida<T> value)? fechaInvalida,
    TResult Function(CargoLongitudInvalida<T> value)? cargoLongitudInvalida,
    TResult Function(SueldoInvalida<T> value)? sueldoInvalido,
    TResult Function(FechaNula<T> value)? fechaNula,
    required TResult orElse(),
  }) {
    if (cargoLongitudInvalida != null) {
      return cargoLongitudInvalida(this);
    }
    return orElse();
  }
}

abstract class CargoLongitudInvalida<T> implements ValorErroneo<T> {
  const factory CargoLongitudInvalida(
      {required T valorErroneo,
      required int min,
      required int max}) = _$CargoLongitudInvalida<T>;

  T get valorErroneo => throw _privateConstructorUsedError;
  int get min => throw _privateConstructorUsedError;
  int get max => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $CargoLongitudInvalidaCopyWith<T, CargoLongitudInvalida<T>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SueldoInvalidaCopyWith<T, $Res> {
  factory $SueldoInvalidaCopyWith(
          SueldoInvalida<T> value, $Res Function(SueldoInvalida<T>) then) =
      _$SueldoInvalidaCopyWithImpl<T, $Res>;
  $Res call({T valorErroneo, double max});
}

/// @nodoc
class _$SueldoInvalidaCopyWithImpl<T, $Res>
    extends _$ValorErroneoCopyWithImpl<T, $Res>
    implements $SueldoInvalidaCopyWith<T, $Res> {
  _$SueldoInvalidaCopyWithImpl(
      SueldoInvalida<T> _value, $Res Function(SueldoInvalida<T>) _then)
      : super(_value, (v) => _then(v as SueldoInvalida<T>));

  @override
  SueldoInvalida<T> get _value => super._value as SueldoInvalida<T>;

  @override
  $Res call({
    Object? valorErroneo = freezed,
    Object? max = freezed,
  }) {
    return _then(SueldoInvalida<T>(
      valorErroneo: valorErroneo == freezed
          ? _value.valorErroneo
          : valorErroneo // ignore: cast_nullable_to_non_nullable
              as T,
      max: max == freezed
          ? _value.max
          : max // ignore: cast_nullable_to_non_nullable
              as double,
    ));
  }
}

/// @nodoc

class _$SueldoInvalida<T> implements SueldoInvalida<T> {
  const _$SueldoInvalida({required this.valorErroneo, required this.max});

  @override
  final T valorErroneo;
  @override
  final double max;

  @override
  String toString() {
    return 'ValorErroneo<$T>.sueldoInvalido(valorErroneo: $valorErroneo, max: $max)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is SueldoInvalida<T> &&
            (identical(other.valorErroneo, valorErroneo) ||
                const DeepCollectionEquality()
                    .equals(other.valorErroneo, valorErroneo)) &&
            (identical(other.max, max) ||
                const DeepCollectionEquality().equals(other.max, max)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(valorErroneo) ^
      const DeepCollectionEquality().hash(max);

  @JsonKey(ignore: true)
  @override
  $SueldoInvalidaCopyWith<T, SueldoInvalida<T>> get copyWith =>
      _$SueldoInvalidaCopyWithImpl<T, SueldoInvalida<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(T valorErroneo, int max) excedeLongitudMaxima,
    required TResult Function(T valorErroneo) emailInvalido,
    required TResult Function(T valorErroneo) contrasenaCorta,
    required TResult Function(T valorErroneo) ciudadInvalida,
    required TResult Function(T valorErroneo) fechaInvalida,
    required TResult Function(T valorErroneo, int min, int max)
        cargoLongitudInvalida,
    required TResult Function(T valorErroneo, double max) sueldoInvalido,
    required TResult Function(T fechaErronea) fechaNula,
  }) {
    return sueldoInvalido(valorErroneo, max);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(T valorErroneo, int max)? excedeLongitudMaxima,
    TResult Function(T valorErroneo)? emailInvalido,
    TResult Function(T valorErroneo)? contrasenaCorta,
    TResult Function(T valorErroneo)? ciudadInvalida,
    TResult Function(T valorErroneo)? fechaInvalida,
    TResult Function(T valorErroneo, int min, int max)? cargoLongitudInvalida,
    TResult Function(T valorErroneo, double max)? sueldoInvalido,
    TResult Function(T fechaErronea)? fechaNula,
    required TResult orElse(),
  }) {
    if (sueldoInvalido != null) {
      return sueldoInvalido(valorErroneo, max);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ExcedeLongitudMaxima<T> value)
        excedeLongitudMaxima,
    required TResult Function(EmailInvalido<T> value) emailInvalido,
    required TResult Function(ContrasenaCorta<T> value) contrasenaCorta,
    required TResult Function(CiudadInvalida<T> value) ciudadInvalida,
    required TResult Function(FechaInvalida<T> value) fechaInvalida,
    required TResult Function(CargoLongitudInvalida<T> value)
        cargoLongitudInvalida,
    required TResult Function(SueldoInvalida<T> value) sueldoInvalido,
    required TResult Function(FechaNula<T> value) fechaNula,
  }) {
    return sueldoInvalido(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ExcedeLongitudMaxima<T> value)? excedeLongitudMaxima,
    TResult Function(EmailInvalido<T> value)? emailInvalido,
    TResult Function(ContrasenaCorta<T> value)? contrasenaCorta,
    TResult Function(CiudadInvalida<T> value)? ciudadInvalida,
    TResult Function(FechaInvalida<T> value)? fechaInvalida,
    TResult Function(CargoLongitudInvalida<T> value)? cargoLongitudInvalida,
    TResult Function(SueldoInvalida<T> value)? sueldoInvalido,
    TResult Function(FechaNula<T> value)? fechaNula,
    required TResult orElse(),
  }) {
    if (sueldoInvalido != null) {
      return sueldoInvalido(this);
    }
    return orElse();
  }
}

abstract class SueldoInvalida<T> implements ValorErroneo<T> {
  const factory SueldoInvalida({required T valorErroneo, required double max}) =
      _$SueldoInvalida<T>;

  T get valorErroneo => throw _privateConstructorUsedError;
  double get max => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $SueldoInvalidaCopyWith<T, SueldoInvalida<T>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $FechaNulaCopyWith<T, $Res> {
  factory $FechaNulaCopyWith(
          FechaNula<T> value, $Res Function(FechaNula<T>) then) =
      _$FechaNulaCopyWithImpl<T, $Res>;
  $Res call({T fechaErronea});
}

/// @nodoc
class _$FechaNulaCopyWithImpl<T, $Res>
    extends _$ValorErroneoCopyWithImpl<T, $Res>
    implements $FechaNulaCopyWith<T, $Res> {
  _$FechaNulaCopyWithImpl(
      FechaNula<T> _value, $Res Function(FechaNula<T>) _then)
      : super(_value, (v) => _then(v as FechaNula<T>));

  @override
  FechaNula<T> get _value => super._value as FechaNula<T>;

  @override
  $Res call({
    Object? fechaErronea = freezed,
  }) {
    return _then(FechaNula<T>(
      fechaErronea: fechaErronea == freezed
          ? _value.fechaErronea
          : fechaErronea // ignore: cast_nullable_to_non_nullable
              as T,
    ));
  }
}

/// @nodoc

class _$FechaNula<T> implements FechaNula<T> {
  const _$FechaNula({required this.fechaErronea});

  @override
  final T fechaErronea;

  @override
  String toString() {
    return 'ValorErroneo<$T>.fechaNula(fechaErronea: $fechaErronea)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is FechaNula<T> &&
            (identical(other.fechaErronea, fechaErronea) ||
                const DeepCollectionEquality()
                    .equals(other.fechaErronea, fechaErronea)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(fechaErronea);

  @JsonKey(ignore: true)
  @override
  $FechaNulaCopyWith<T, FechaNula<T>> get copyWith =>
      _$FechaNulaCopyWithImpl<T, FechaNula<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(T valorErroneo, int max) excedeLongitudMaxima,
    required TResult Function(T valorErroneo) emailInvalido,
    required TResult Function(T valorErroneo) contrasenaCorta,
    required TResult Function(T valorErroneo) ciudadInvalida,
    required TResult Function(T valorErroneo) fechaInvalida,
    required TResult Function(T valorErroneo, int min, int max)
        cargoLongitudInvalida,
    required TResult Function(T valorErroneo, double max) sueldoInvalido,
    required TResult Function(T fechaErronea) fechaNula,
  }) {
    return fechaNula(fechaErronea);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(T valorErroneo, int max)? excedeLongitudMaxima,
    TResult Function(T valorErroneo)? emailInvalido,
    TResult Function(T valorErroneo)? contrasenaCorta,
    TResult Function(T valorErroneo)? ciudadInvalida,
    TResult Function(T valorErroneo)? fechaInvalida,
    TResult Function(T valorErroneo, int min, int max)? cargoLongitudInvalida,
    TResult Function(T valorErroneo, double max)? sueldoInvalido,
    TResult Function(T fechaErronea)? fechaNula,
    required TResult orElse(),
  }) {
    if (fechaNula != null) {
      return fechaNula(fechaErronea);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ExcedeLongitudMaxima<T> value)
        excedeLongitudMaxima,
    required TResult Function(EmailInvalido<T> value) emailInvalido,
    required TResult Function(ContrasenaCorta<T> value) contrasenaCorta,
    required TResult Function(CiudadInvalida<T> value) ciudadInvalida,
    required TResult Function(FechaInvalida<T> value) fechaInvalida,
    required TResult Function(CargoLongitudInvalida<T> value)
        cargoLongitudInvalida,
    required TResult Function(SueldoInvalida<T> value) sueldoInvalido,
    required TResult Function(FechaNula<T> value) fechaNula,
  }) {
    return fechaNula(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ExcedeLongitudMaxima<T> value)? excedeLongitudMaxima,
    TResult Function(EmailInvalido<T> value)? emailInvalido,
    TResult Function(ContrasenaCorta<T> value)? contrasenaCorta,
    TResult Function(CiudadInvalida<T> value)? ciudadInvalida,
    TResult Function(FechaInvalida<T> value)? fechaInvalida,
    TResult Function(CargoLongitudInvalida<T> value)? cargoLongitudInvalida,
    TResult Function(SueldoInvalida<T> value)? sueldoInvalido,
    TResult Function(FechaNula<T> value)? fechaNula,
    required TResult orElse(),
  }) {
    if (fechaNula != null) {
      return fechaNula(this);
    }
    return orElse();
  }
}

abstract class FechaNula<T> implements ValorErroneo<T> {
  const factory FechaNula({required T fechaErronea}) = _$FechaNula<T>;

  T get fechaErronea => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $FechaNulaCopyWith<T, FechaNula<T>> get copyWith =>
      throw _privateConstructorUsedError;
}
