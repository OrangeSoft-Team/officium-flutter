// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides

part of 'factoria_valor_erroneo.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more informations: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
class _$ValorErroneoTearOff {
  const _$ValorErroneoTearOff();

  EmailInvalido<T> emailInvalido<T>({required T valorErroneo}) {
    return EmailInvalido<T>(
      valorErroneo: valorErroneo,
    );
  }

  ContrasenaCorta<T> contrasenaCorta<T>({required T valorErroneo}) {
    return ContrasenaCorta<T>(
      valorErroneo: valorErroneo,
    );
  }

  StringVacio<T> stringVacio<T>({required T valorErroneo}) {
    return StringVacio<T>(
      valorErroneo: valorErroneo,
    );
  }

  LongitudInvalida<T> longitudInvalida<T>(
      {required T valorErroneo, required int min, required int max}) {
    return LongitudInvalida<T>(
      valorErroneo: valorErroneo,
      min: min,
      max: max,
    );
  }

  SueldoInvalida<T> sueldoInvalido<T>(
      {required T valorErroneo, required double max}) {
    return SueldoInvalida<T>(
      valorErroneo: valorErroneo,
      max: max,
    );
  }

  SueldoVacio<T> sueldoVacio<T>({required T valorErroneo}) {
    return SueldoVacio<T>(
      valorErroneo: valorErroneo,
    );
  }

  FechaNula<T> fechaNula<T>({required T fechaErronea}) {
    return FechaNula<T>(
      fechaErronea: fechaErronea,
    );
  }

  NumVacantesInvalido<T> numVacantesInvalido<T>(
      {required T numVacantesInvalido}) {
    return NumVacantesInvalido<T>(
      numVacantesInvalido: numVacantesInvalido,
    );
  }

  NumVacantesNoVacia<T> numVacantesNoVacia<T>({required T valorErroneo}) {
    return NumVacantesNoVacia<T>(
      valorErroneo: valorErroneo,
    );
  }

  TurnoInvalido<T> turnoInvalido<T>(
      {required T valorErroneo, required List<String> turnosValidos}) {
    return TurnoInvalido<T>(
      valorErroneo: valorErroneo,
      turnosValidos: turnosValidos,
    );
  }

  GeneroInvalido<T> generoInvalido<T>(
      {required T valorErroneo, required List<String> generosValidos}) {
    return GeneroInvalido<T>(
      valorErroneo: valorErroneo,
      generosValidos: generosValidos,
    );
  }
}

/// @nodoc
const $ValorErroneo = _$ValorErroneoTearOff();

/// @nodoc
mixin _$ValorErroneo<T> {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(T valorErroneo) emailInvalido,
    required TResult Function(T valorErroneo) contrasenaCorta,
    required TResult Function(T valorErroneo) stringVacio,
    required TResult Function(T valorErroneo, int min, int max)
        longitudInvalida,
    required TResult Function(T valorErroneo, double max) sueldoInvalido,
    required TResult Function(T valorErroneo) sueldoVacio,
    required TResult Function(T fechaErronea) fechaNula,
    required TResult Function(T numVacantesInvalido) numVacantesInvalido,
    required TResult Function(T valorErroneo) numVacantesNoVacia,
    required TResult Function(T valorErroneo, List<String> turnosValidos)
        turnoInvalido,
    required TResult Function(T valorErroneo, List<String> generosValidos)
        generoInvalido,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(T valorErroneo)? emailInvalido,
    TResult Function(T valorErroneo)? contrasenaCorta,
    TResult Function(T valorErroneo)? stringVacio,
    TResult Function(T valorErroneo, int min, int max)? longitudInvalida,
    TResult Function(T valorErroneo, double max)? sueldoInvalido,
    TResult Function(T valorErroneo)? sueldoVacio,
    TResult Function(T fechaErronea)? fechaNula,
    TResult Function(T numVacantesInvalido)? numVacantesInvalido,
    TResult Function(T valorErroneo)? numVacantesNoVacia,
    TResult Function(T valorErroneo, List<String> turnosValidos)? turnoInvalido,
    TResult Function(T valorErroneo, List<String> generosValidos)?
        generoInvalido,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(EmailInvalido<T> value) emailInvalido,
    required TResult Function(ContrasenaCorta<T> value) contrasenaCorta,
    required TResult Function(StringVacio<T> value) stringVacio,
    required TResult Function(LongitudInvalida<T> value) longitudInvalida,
    required TResult Function(SueldoInvalida<T> value) sueldoInvalido,
    required TResult Function(SueldoVacio<T> value) sueldoVacio,
    required TResult Function(FechaNula<T> value) fechaNula,
    required TResult Function(NumVacantesInvalido<T> value) numVacantesInvalido,
    required TResult Function(NumVacantesNoVacia<T> value) numVacantesNoVacia,
    required TResult Function(TurnoInvalido<T> value) turnoInvalido,
    required TResult Function(GeneroInvalido<T> value) generoInvalido,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(EmailInvalido<T> value)? emailInvalido,
    TResult Function(ContrasenaCorta<T> value)? contrasenaCorta,
    TResult Function(StringVacio<T> value)? stringVacio,
    TResult Function(LongitudInvalida<T> value)? longitudInvalida,
    TResult Function(SueldoInvalida<T> value)? sueldoInvalido,
    TResult Function(SueldoVacio<T> value)? sueldoVacio,
    TResult Function(FechaNula<T> value)? fechaNula,
    TResult Function(NumVacantesInvalido<T> value)? numVacantesInvalido,
    TResult Function(NumVacantesNoVacia<T> value)? numVacantesNoVacia,
    TResult Function(TurnoInvalido<T> value)? turnoInvalido,
    TResult Function(GeneroInvalido<T> value)? generoInvalido,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ValorErroneoCopyWith<T, $Res> {
  factory $ValorErroneoCopyWith(
          ValorErroneo<T> value, $Res Function(ValorErroneo<T>) then) =
      _$ValorErroneoCopyWithImpl<T, $Res>;
}

/// @nodoc
class _$ValorErroneoCopyWithImpl<T, $Res>
    implements $ValorErroneoCopyWith<T, $Res> {
  _$ValorErroneoCopyWithImpl(this._value, this._then);

  final ValorErroneo<T> _value;
  // ignore: unused_field
  final $Res Function(ValorErroneo<T>) _then;
}

/// @nodoc
abstract class $EmailInvalidoCopyWith<T, $Res> {
  factory $EmailInvalidoCopyWith(
          EmailInvalido<T> value, $Res Function(EmailInvalido<T>) then) =
      _$EmailInvalidoCopyWithImpl<T, $Res>;
  $Res call({T valorErroneo});
}

/// @nodoc
class _$EmailInvalidoCopyWithImpl<T, $Res>
    extends _$ValorErroneoCopyWithImpl<T, $Res>
    implements $EmailInvalidoCopyWith<T, $Res> {
  _$EmailInvalidoCopyWithImpl(
      EmailInvalido<T> _value, $Res Function(EmailInvalido<T>) _then)
      : super(_value, (v) => _then(v as EmailInvalido<T>));

  @override
  EmailInvalido<T> get _value => super._value as EmailInvalido<T>;

  @override
  $Res call({
    Object? valorErroneo = freezed,
  }) {
    return _then(EmailInvalido<T>(
      valorErroneo: valorErroneo == freezed
          ? _value.valorErroneo
          : valorErroneo // ignore: cast_nullable_to_non_nullable
              as T,
    ));
  }
}

/// @nodoc

class _$EmailInvalido<T> implements EmailInvalido<T> {
  const _$EmailInvalido({required this.valorErroneo});

  @override
  final T valorErroneo;

  @override
  String toString() {
    return 'ValorErroneo<$T>.emailInvalido(valorErroneo: $valorErroneo)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is EmailInvalido<T> &&
            (identical(other.valorErroneo, valorErroneo) ||
                const DeepCollectionEquality()
                    .equals(other.valorErroneo, valorErroneo)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(valorErroneo);

  @JsonKey(ignore: true)
  @override
  $EmailInvalidoCopyWith<T, EmailInvalido<T>> get copyWith =>
      _$EmailInvalidoCopyWithImpl<T, EmailInvalido<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(T valorErroneo) emailInvalido,
    required TResult Function(T valorErroneo) contrasenaCorta,
    required TResult Function(T valorErroneo) stringVacio,
    required TResult Function(T valorErroneo, int min, int max)
        longitudInvalida,
    required TResult Function(T valorErroneo, double max) sueldoInvalido,
    required TResult Function(T valorErroneo) sueldoVacio,
    required TResult Function(T fechaErronea) fechaNula,
    required TResult Function(T numVacantesInvalido) numVacantesInvalido,
    required TResult Function(T valorErroneo) numVacantesNoVacia,
    required TResult Function(T valorErroneo, List<String> turnosValidos)
        turnoInvalido,
    required TResult Function(T valorErroneo, List<String> generosValidos)
        generoInvalido,
  }) {
    return emailInvalido(valorErroneo);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(T valorErroneo)? emailInvalido,
    TResult Function(T valorErroneo)? contrasenaCorta,
    TResult Function(T valorErroneo)? stringVacio,
    TResult Function(T valorErroneo, int min, int max)? longitudInvalida,
    TResult Function(T valorErroneo, double max)? sueldoInvalido,
    TResult Function(T valorErroneo)? sueldoVacio,
    TResult Function(T fechaErronea)? fechaNula,
    TResult Function(T numVacantesInvalido)? numVacantesInvalido,
    TResult Function(T valorErroneo)? numVacantesNoVacia,
    TResult Function(T valorErroneo, List<String> turnosValidos)? turnoInvalido,
    TResult Function(T valorErroneo, List<String> generosValidos)?
        generoInvalido,
    required TResult orElse(),
  }) {
    if (emailInvalido != null) {
      return emailInvalido(valorErroneo);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(EmailInvalido<T> value) emailInvalido,
    required TResult Function(ContrasenaCorta<T> value) contrasenaCorta,
    required TResult Function(StringVacio<T> value) stringVacio,
    required TResult Function(LongitudInvalida<T> value) longitudInvalida,
    required TResult Function(SueldoInvalida<T> value) sueldoInvalido,
    required TResult Function(SueldoVacio<T> value) sueldoVacio,
    required TResult Function(FechaNula<T> value) fechaNula,
    required TResult Function(NumVacantesInvalido<T> value) numVacantesInvalido,
    required TResult Function(NumVacantesNoVacia<T> value) numVacantesNoVacia,
    required TResult Function(TurnoInvalido<T> value) turnoInvalido,
    required TResult Function(GeneroInvalido<T> value) generoInvalido,
  }) {
    return emailInvalido(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(EmailInvalido<T> value)? emailInvalido,
    TResult Function(ContrasenaCorta<T> value)? contrasenaCorta,
    TResult Function(StringVacio<T> value)? stringVacio,
    TResult Function(LongitudInvalida<T> value)? longitudInvalida,
    TResult Function(SueldoInvalida<T> value)? sueldoInvalido,
    TResult Function(SueldoVacio<T> value)? sueldoVacio,
    TResult Function(FechaNula<T> value)? fechaNula,
    TResult Function(NumVacantesInvalido<T> value)? numVacantesInvalido,
    TResult Function(NumVacantesNoVacia<T> value)? numVacantesNoVacia,
    TResult Function(TurnoInvalido<T> value)? turnoInvalido,
    TResult Function(GeneroInvalido<T> value)? generoInvalido,
    required TResult orElse(),
  }) {
    if (emailInvalido != null) {
      return emailInvalido(this);
    }
    return orElse();
  }
}

abstract class EmailInvalido<T> implements ValorErroneo<T> {
  const factory EmailInvalido({required T valorErroneo}) = _$EmailInvalido<T>;

  T get valorErroneo => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $EmailInvalidoCopyWith<T, EmailInvalido<T>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ContrasenaCortaCopyWith<T, $Res> {
  factory $ContrasenaCortaCopyWith(
          ContrasenaCorta<T> value, $Res Function(ContrasenaCorta<T>) then) =
      _$ContrasenaCortaCopyWithImpl<T, $Res>;
  $Res call({T valorErroneo});
}

/// @nodoc
class _$ContrasenaCortaCopyWithImpl<T, $Res>
    extends _$ValorErroneoCopyWithImpl<T, $Res>
    implements $ContrasenaCortaCopyWith<T, $Res> {
  _$ContrasenaCortaCopyWithImpl(
      ContrasenaCorta<T> _value, $Res Function(ContrasenaCorta<T>) _then)
      : super(_value, (v) => _then(v as ContrasenaCorta<T>));

  @override
  ContrasenaCorta<T> get _value => super._value as ContrasenaCorta<T>;

  @override
  $Res call({
    Object? valorErroneo = freezed,
  }) {
    return _then(ContrasenaCorta<T>(
      valorErroneo: valorErroneo == freezed
          ? _value.valorErroneo
          : valorErroneo // ignore: cast_nullable_to_non_nullable
              as T,
    ));
  }
}

/// @nodoc

class _$ContrasenaCorta<T> implements ContrasenaCorta<T> {
  const _$ContrasenaCorta({required this.valorErroneo});

  @override
  final T valorErroneo;

  @override
  String toString() {
    return 'ValorErroneo<$T>.contrasenaCorta(valorErroneo: $valorErroneo)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is ContrasenaCorta<T> &&
            (identical(other.valorErroneo, valorErroneo) ||
                const DeepCollectionEquality()
                    .equals(other.valorErroneo, valorErroneo)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(valorErroneo);

  @JsonKey(ignore: true)
  @override
  $ContrasenaCortaCopyWith<T, ContrasenaCorta<T>> get copyWith =>
      _$ContrasenaCortaCopyWithImpl<T, ContrasenaCorta<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(T valorErroneo) emailInvalido,
    required TResult Function(T valorErroneo) contrasenaCorta,
    required TResult Function(T valorErroneo) stringVacio,
    required TResult Function(T valorErroneo, int min, int max)
        longitudInvalida,
    required TResult Function(T valorErroneo, double max) sueldoInvalido,
    required TResult Function(T valorErroneo) sueldoVacio,
    required TResult Function(T fechaErronea) fechaNula,
    required TResult Function(T numVacantesInvalido) numVacantesInvalido,
    required TResult Function(T valorErroneo) numVacantesNoVacia,
    required TResult Function(T valorErroneo, List<String> turnosValidos)
        turnoInvalido,
    required TResult Function(T valorErroneo, List<String> generosValidos)
        generoInvalido,
  }) {
    return contrasenaCorta(valorErroneo);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(T valorErroneo)? emailInvalido,
    TResult Function(T valorErroneo)? contrasenaCorta,
    TResult Function(T valorErroneo)? stringVacio,
    TResult Function(T valorErroneo, int min, int max)? longitudInvalida,
    TResult Function(T valorErroneo, double max)? sueldoInvalido,
    TResult Function(T valorErroneo)? sueldoVacio,
    TResult Function(T fechaErronea)? fechaNula,
    TResult Function(T numVacantesInvalido)? numVacantesInvalido,
    TResult Function(T valorErroneo)? numVacantesNoVacia,
    TResult Function(T valorErroneo, List<String> turnosValidos)? turnoInvalido,
    TResult Function(T valorErroneo, List<String> generosValidos)?
        generoInvalido,
    required TResult orElse(),
  }) {
    if (contrasenaCorta != null) {
      return contrasenaCorta(valorErroneo);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(EmailInvalido<T> value) emailInvalido,
    required TResult Function(ContrasenaCorta<T> value) contrasenaCorta,
    required TResult Function(StringVacio<T> value) stringVacio,
    required TResult Function(LongitudInvalida<T> value) longitudInvalida,
    required TResult Function(SueldoInvalida<T> value) sueldoInvalido,
    required TResult Function(SueldoVacio<T> value) sueldoVacio,
    required TResult Function(FechaNula<T> value) fechaNula,
    required TResult Function(NumVacantesInvalido<T> value) numVacantesInvalido,
    required TResult Function(NumVacantesNoVacia<T> value) numVacantesNoVacia,
    required TResult Function(TurnoInvalido<T> value) turnoInvalido,
    required TResult Function(GeneroInvalido<T> value) generoInvalido,
  }) {
    return contrasenaCorta(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(EmailInvalido<T> value)? emailInvalido,
    TResult Function(ContrasenaCorta<T> value)? contrasenaCorta,
    TResult Function(StringVacio<T> value)? stringVacio,
    TResult Function(LongitudInvalida<T> value)? longitudInvalida,
    TResult Function(SueldoInvalida<T> value)? sueldoInvalido,
    TResult Function(SueldoVacio<T> value)? sueldoVacio,
    TResult Function(FechaNula<T> value)? fechaNula,
    TResult Function(NumVacantesInvalido<T> value)? numVacantesInvalido,
    TResult Function(NumVacantesNoVacia<T> value)? numVacantesNoVacia,
    TResult Function(TurnoInvalido<T> value)? turnoInvalido,
    TResult Function(GeneroInvalido<T> value)? generoInvalido,
    required TResult orElse(),
  }) {
    if (contrasenaCorta != null) {
      return contrasenaCorta(this);
    }
    return orElse();
  }
}

abstract class ContrasenaCorta<T> implements ValorErroneo<T> {
  const factory ContrasenaCorta({required T valorErroneo}) =
      _$ContrasenaCorta<T>;

  T get valorErroneo => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ContrasenaCortaCopyWith<T, ContrasenaCorta<T>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $StringVacioCopyWith<T, $Res> {
  factory $StringVacioCopyWith(
          StringVacio<T> value, $Res Function(StringVacio<T>) then) =
      _$StringVacioCopyWithImpl<T, $Res>;
  $Res call({T valorErroneo});
}

/// @nodoc
class _$StringVacioCopyWithImpl<T, $Res>
    extends _$ValorErroneoCopyWithImpl<T, $Res>
    implements $StringVacioCopyWith<T, $Res> {
  _$StringVacioCopyWithImpl(
      StringVacio<T> _value, $Res Function(StringVacio<T>) _then)
      : super(_value, (v) => _then(v as StringVacio<T>));

  @override
  StringVacio<T> get _value => super._value as StringVacio<T>;

  @override
  $Res call({
    Object? valorErroneo = freezed,
  }) {
    return _then(StringVacio<T>(
      valorErroneo: valorErroneo == freezed
          ? _value.valorErroneo
          : valorErroneo // ignore: cast_nullable_to_non_nullable
              as T,
    ));
  }
}

/// @nodoc

class _$StringVacio<T> implements StringVacio<T> {
  const _$StringVacio({required this.valorErroneo});

  @override
  final T valorErroneo;

  @override
  String toString() {
    return 'ValorErroneo<$T>.stringVacio(valorErroneo: $valorErroneo)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is StringVacio<T> &&
            (identical(other.valorErroneo, valorErroneo) ||
                const DeepCollectionEquality()
                    .equals(other.valorErroneo, valorErroneo)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(valorErroneo);

  @JsonKey(ignore: true)
  @override
  $StringVacioCopyWith<T, StringVacio<T>> get copyWith =>
      _$StringVacioCopyWithImpl<T, StringVacio<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(T valorErroneo) emailInvalido,
    required TResult Function(T valorErroneo) contrasenaCorta,
    required TResult Function(T valorErroneo) stringVacio,
    required TResult Function(T valorErroneo, int min, int max)
        longitudInvalida,
    required TResult Function(T valorErroneo, double max) sueldoInvalido,
    required TResult Function(T valorErroneo) sueldoVacio,
    required TResult Function(T fechaErronea) fechaNula,
    required TResult Function(T numVacantesInvalido) numVacantesInvalido,
    required TResult Function(T valorErroneo) numVacantesNoVacia,
    required TResult Function(T valorErroneo, List<String> turnosValidos)
        turnoInvalido,
    required TResult Function(T valorErroneo, List<String> generosValidos)
        generoInvalido,
  }) {
    return stringVacio(valorErroneo);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(T valorErroneo)? emailInvalido,
    TResult Function(T valorErroneo)? contrasenaCorta,
    TResult Function(T valorErroneo)? stringVacio,
    TResult Function(T valorErroneo, int min, int max)? longitudInvalida,
    TResult Function(T valorErroneo, double max)? sueldoInvalido,
    TResult Function(T valorErroneo)? sueldoVacio,
    TResult Function(T fechaErronea)? fechaNula,
    TResult Function(T numVacantesInvalido)? numVacantesInvalido,
    TResult Function(T valorErroneo)? numVacantesNoVacia,
    TResult Function(T valorErroneo, List<String> turnosValidos)? turnoInvalido,
    TResult Function(T valorErroneo, List<String> generosValidos)?
        generoInvalido,
    required TResult orElse(),
  }) {
    if (stringVacio != null) {
      return stringVacio(valorErroneo);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(EmailInvalido<T> value) emailInvalido,
    required TResult Function(ContrasenaCorta<T> value) contrasenaCorta,
    required TResult Function(StringVacio<T> value) stringVacio,
    required TResult Function(LongitudInvalida<T> value) longitudInvalida,
    required TResult Function(SueldoInvalida<T> value) sueldoInvalido,
    required TResult Function(SueldoVacio<T> value) sueldoVacio,
    required TResult Function(FechaNula<T> value) fechaNula,
    required TResult Function(NumVacantesInvalido<T> value) numVacantesInvalido,
    required TResult Function(NumVacantesNoVacia<T> value) numVacantesNoVacia,
    required TResult Function(TurnoInvalido<T> value) turnoInvalido,
    required TResult Function(GeneroInvalido<T> value) generoInvalido,
  }) {
    return stringVacio(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(EmailInvalido<T> value)? emailInvalido,
    TResult Function(ContrasenaCorta<T> value)? contrasenaCorta,
    TResult Function(StringVacio<T> value)? stringVacio,
    TResult Function(LongitudInvalida<T> value)? longitudInvalida,
    TResult Function(SueldoInvalida<T> value)? sueldoInvalido,
    TResult Function(SueldoVacio<T> value)? sueldoVacio,
    TResult Function(FechaNula<T> value)? fechaNula,
    TResult Function(NumVacantesInvalido<T> value)? numVacantesInvalido,
    TResult Function(NumVacantesNoVacia<T> value)? numVacantesNoVacia,
    TResult Function(TurnoInvalido<T> value)? turnoInvalido,
    TResult Function(GeneroInvalido<T> value)? generoInvalido,
    required TResult orElse(),
  }) {
    if (stringVacio != null) {
      return stringVacio(this);
    }
    return orElse();
  }
}

abstract class StringVacio<T> implements ValorErroneo<T> {
  const factory StringVacio({required T valorErroneo}) = _$StringVacio<T>;

  T get valorErroneo => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $StringVacioCopyWith<T, StringVacio<T>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $LongitudInvalidaCopyWith<T, $Res> {
  factory $LongitudInvalidaCopyWith(
          LongitudInvalida<T> value, $Res Function(LongitudInvalida<T>) then) =
      _$LongitudInvalidaCopyWithImpl<T, $Res>;
  $Res call({T valorErroneo, int min, int max});
}

/// @nodoc
class _$LongitudInvalidaCopyWithImpl<T, $Res>
    extends _$ValorErroneoCopyWithImpl<T, $Res>
    implements $LongitudInvalidaCopyWith<T, $Res> {
  _$LongitudInvalidaCopyWithImpl(
      LongitudInvalida<T> _value, $Res Function(LongitudInvalida<T>) _then)
      : super(_value, (v) => _then(v as LongitudInvalida<T>));

  @override
  LongitudInvalida<T> get _value => super._value as LongitudInvalida<T>;

  @override
  $Res call({
    Object? valorErroneo = freezed,
    Object? min = freezed,
    Object? max = freezed,
  }) {
    return _then(LongitudInvalida<T>(
      valorErroneo: valorErroneo == freezed
          ? _value.valorErroneo
          : valorErroneo // ignore: cast_nullable_to_non_nullable
              as T,
      min: min == freezed
          ? _value.min
          : min // ignore: cast_nullable_to_non_nullable
              as int,
      max: max == freezed
          ? _value.max
          : max // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$LongitudInvalida<T> implements LongitudInvalida<T> {
  const _$LongitudInvalida(
      {required this.valorErroneo, required this.min, required this.max});

  @override
  final T valorErroneo;
  @override
  final int min;
  @override
  final int max;

  @override
  String toString() {
    return 'ValorErroneo<$T>.longitudInvalida(valorErroneo: $valorErroneo, min: $min, max: $max)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is LongitudInvalida<T> &&
            (identical(other.valorErroneo, valorErroneo) ||
                const DeepCollectionEquality()
                    .equals(other.valorErroneo, valorErroneo)) &&
            (identical(other.min, min) ||
                const DeepCollectionEquality().equals(other.min, min)) &&
            (identical(other.max, max) ||
                const DeepCollectionEquality().equals(other.max, max)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(valorErroneo) ^
      const DeepCollectionEquality().hash(min) ^
      const DeepCollectionEquality().hash(max);

  @JsonKey(ignore: true)
  @override
  $LongitudInvalidaCopyWith<T, LongitudInvalida<T>> get copyWith =>
      _$LongitudInvalidaCopyWithImpl<T, LongitudInvalida<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(T valorErroneo) emailInvalido,
    required TResult Function(T valorErroneo) contrasenaCorta,
    required TResult Function(T valorErroneo) stringVacio,
    required TResult Function(T valorErroneo, int min, int max)
        longitudInvalida,
    required TResult Function(T valorErroneo, double max) sueldoInvalido,
    required TResult Function(T valorErroneo) sueldoVacio,
    required TResult Function(T fechaErronea) fechaNula,
    required TResult Function(T numVacantesInvalido) numVacantesInvalido,
    required TResult Function(T valorErroneo) numVacantesNoVacia,
    required TResult Function(T valorErroneo, List<String> turnosValidos)
        turnoInvalido,
    required TResult Function(T valorErroneo, List<String> generosValidos)
        generoInvalido,
  }) {
    return longitudInvalida(valorErroneo, min, max);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(T valorErroneo)? emailInvalido,
    TResult Function(T valorErroneo)? contrasenaCorta,
    TResult Function(T valorErroneo)? stringVacio,
    TResult Function(T valorErroneo, int min, int max)? longitudInvalida,
    TResult Function(T valorErroneo, double max)? sueldoInvalido,
    TResult Function(T valorErroneo)? sueldoVacio,
    TResult Function(T fechaErronea)? fechaNula,
    TResult Function(T numVacantesInvalido)? numVacantesInvalido,
    TResult Function(T valorErroneo)? numVacantesNoVacia,
    TResult Function(T valorErroneo, List<String> turnosValidos)? turnoInvalido,
    TResult Function(T valorErroneo, List<String> generosValidos)?
        generoInvalido,
    required TResult orElse(),
  }) {
    if (longitudInvalida != null) {
      return longitudInvalida(valorErroneo, min, max);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(EmailInvalido<T> value) emailInvalido,
    required TResult Function(ContrasenaCorta<T> value) contrasenaCorta,
    required TResult Function(StringVacio<T> value) stringVacio,
    required TResult Function(LongitudInvalida<T> value) longitudInvalida,
    required TResult Function(SueldoInvalida<T> value) sueldoInvalido,
    required TResult Function(SueldoVacio<T> value) sueldoVacio,
    required TResult Function(FechaNula<T> value) fechaNula,
    required TResult Function(NumVacantesInvalido<T> value) numVacantesInvalido,
    required TResult Function(NumVacantesNoVacia<T> value) numVacantesNoVacia,
    required TResult Function(TurnoInvalido<T> value) turnoInvalido,
    required TResult Function(GeneroInvalido<T> value) generoInvalido,
  }) {
    return longitudInvalida(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(EmailInvalido<T> value)? emailInvalido,
    TResult Function(ContrasenaCorta<T> value)? contrasenaCorta,
    TResult Function(StringVacio<T> value)? stringVacio,
    TResult Function(LongitudInvalida<T> value)? longitudInvalida,
    TResult Function(SueldoInvalida<T> value)? sueldoInvalido,
    TResult Function(SueldoVacio<T> value)? sueldoVacio,
    TResult Function(FechaNula<T> value)? fechaNula,
    TResult Function(NumVacantesInvalido<T> value)? numVacantesInvalido,
    TResult Function(NumVacantesNoVacia<T> value)? numVacantesNoVacia,
    TResult Function(TurnoInvalido<T> value)? turnoInvalido,
    TResult Function(GeneroInvalido<T> value)? generoInvalido,
    required TResult orElse(),
  }) {
    if (longitudInvalida != null) {
      return longitudInvalida(this);
    }
    return orElse();
  }
}

abstract class LongitudInvalida<T> implements ValorErroneo<T> {
  const factory LongitudInvalida(
      {required T valorErroneo,
      required int min,
      required int max}) = _$LongitudInvalida<T>;

  T get valorErroneo => throw _privateConstructorUsedError;
  int get min => throw _privateConstructorUsedError;
  int get max => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $LongitudInvalidaCopyWith<T, LongitudInvalida<T>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SueldoInvalidaCopyWith<T, $Res> {
  factory $SueldoInvalidaCopyWith(
          SueldoInvalida<T> value, $Res Function(SueldoInvalida<T>) then) =
      _$SueldoInvalidaCopyWithImpl<T, $Res>;
  $Res call({T valorErroneo, double max});
}

/// @nodoc
class _$SueldoInvalidaCopyWithImpl<T, $Res>
    extends _$ValorErroneoCopyWithImpl<T, $Res>
    implements $SueldoInvalidaCopyWith<T, $Res> {
  _$SueldoInvalidaCopyWithImpl(
      SueldoInvalida<T> _value, $Res Function(SueldoInvalida<T>) _then)
      : super(_value, (v) => _then(v as SueldoInvalida<T>));

  @override
  SueldoInvalida<T> get _value => super._value as SueldoInvalida<T>;

  @override
  $Res call({
    Object? valorErroneo = freezed,
    Object? max = freezed,
  }) {
    return _then(SueldoInvalida<T>(
      valorErroneo: valorErroneo == freezed
          ? _value.valorErroneo
          : valorErroneo // ignore: cast_nullable_to_non_nullable
              as T,
      max: max == freezed
          ? _value.max
          : max // ignore: cast_nullable_to_non_nullable
              as double,
    ));
  }
}

/// @nodoc

class _$SueldoInvalida<T> implements SueldoInvalida<T> {
  const _$SueldoInvalida({required this.valorErroneo, required this.max});

  @override
  final T valorErroneo;
  @override
  final double max;

  @override
  String toString() {
    return 'ValorErroneo<$T>.sueldoInvalido(valorErroneo: $valorErroneo, max: $max)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is SueldoInvalida<T> &&
            (identical(other.valorErroneo, valorErroneo) ||
                const DeepCollectionEquality()
                    .equals(other.valorErroneo, valorErroneo)) &&
            (identical(other.max, max) ||
                const DeepCollectionEquality().equals(other.max, max)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(valorErroneo) ^
      const DeepCollectionEquality().hash(max);

  @JsonKey(ignore: true)
  @override
  $SueldoInvalidaCopyWith<T, SueldoInvalida<T>> get copyWith =>
      _$SueldoInvalidaCopyWithImpl<T, SueldoInvalida<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(T valorErroneo) emailInvalido,
    required TResult Function(T valorErroneo) contrasenaCorta,
    required TResult Function(T valorErroneo) stringVacio,
    required TResult Function(T valorErroneo, int min, int max)
        longitudInvalida,
    required TResult Function(T valorErroneo, double max) sueldoInvalido,
    required TResult Function(T valorErroneo) sueldoVacio,
    required TResult Function(T fechaErronea) fechaNula,
    required TResult Function(T numVacantesInvalido) numVacantesInvalido,
    required TResult Function(T valorErroneo) numVacantesNoVacia,
    required TResult Function(T valorErroneo, List<String> turnosValidos)
        turnoInvalido,
    required TResult Function(T valorErroneo, List<String> generosValidos)
        generoInvalido,
  }) {
    return sueldoInvalido(valorErroneo, max);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(T valorErroneo)? emailInvalido,
    TResult Function(T valorErroneo)? contrasenaCorta,
    TResult Function(T valorErroneo)? stringVacio,
    TResult Function(T valorErroneo, int min, int max)? longitudInvalida,
    TResult Function(T valorErroneo, double max)? sueldoInvalido,
    TResult Function(T valorErroneo)? sueldoVacio,
    TResult Function(T fechaErronea)? fechaNula,
    TResult Function(T numVacantesInvalido)? numVacantesInvalido,
    TResult Function(T valorErroneo)? numVacantesNoVacia,
    TResult Function(T valorErroneo, List<String> turnosValidos)? turnoInvalido,
    TResult Function(T valorErroneo, List<String> generosValidos)?
        generoInvalido,
    required TResult orElse(),
  }) {
    if (sueldoInvalido != null) {
      return sueldoInvalido(valorErroneo, max);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(EmailInvalido<T> value) emailInvalido,
    required TResult Function(ContrasenaCorta<T> value) contrasenaCorta,
    required TResult Function(StringVacio<T> value) stringVacio,
    required TResult Function(LongitudInvalida<T> value) longitudInvalida,
    required TResult Function(SueldoInvalida<T> value) sueldoInvalido,
    required TResult Function(SueldoVacio<T> value) sueldoVacio,
    required TResult Function(FechaNula<T> value) fechaNula,
    required TResult Function(NumVacantesInvalido<T> value) numVacantesInvalido,
    required TResult Function(NumVacantesNoVacia<T> value) numVacantesNoVacia,
    required TResult Function(TurnoInvalido<T> value) turnoInvalido,
    required TResult Function(GeneroInvalido<T> value) generoInvalido,
  }) {
    return sueldoInvalido(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(EmailInvalido<T> value)? emailInvalido,
    TResult Function(ContrasenaCorta<T> value)? contrasenaCorta,
    TResult Function(StringVacio<T> value)? stringVacio,
    TResult Function(LongitudInvalida<T> value)? longitudInvalida,
    TResult Function(SueldoInvalida<T> value)? sueldoInvalido,
    TResult Function(SueldoVacio<T> value)? sueldoVacio,
    TResult Function(FechaNula<T> value)? fechaNula,
    TResult Function(NumVacantesInvalido<T> value)? numVacantesInvalido,
    TResult Function(NumVacantesNoVacia<T> value)? numVacantesNoVacia,
    TResult Function(TurnoInvalido<T> value)? turnoInvalido,
    TResult Function(GeneroInvalido<T> value)? generoInvalido,
    required TResult orElse(),
  }) {
    if (sueldoInvalido != null) {
      return sueldoInvalido(this);
    }
    return orElse();
  }
}

abstract class SueldoInvalida<T> implements ValorErroneo<T> {
  const factory SueldoInvalida({required T valorErroneo, required double max}) =
      _$SueldoInvalida<T>;

  T get valorErroneo => throw _privateConstructorUsedError;
  double get max => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $SueldoInvalidaCopyWith<T, SueldoInvalida<T>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SueldoVacioCopyWith<T, $Res> {
  factory $SueldoVacioCopyWith(
          SueldoVacio<T> value, $Res Function(SueldoVacio<T>) then) =
      _$SueldoVacioCopyWithImpl<T, $Res>;
  $Res call({T valorErroneo});
}

/// @nodoc
class _$SueldoVacioCopyWithImpl<T, $Res>
    extends _$ValorErroneoCopyWithImpl<T, $Res>
    implements $SueldoVacioCopyWith<T, $Res> {
  _$SueldoVacioCopyWithImpl(
      SueldoVacio<T> _value, $Res Function(SueldoVacio<T>) _then)
      : super(_value, (v) => _then(v as SueldoVacio<T>));

  @override
  SueldoVacio<T> get _value => super._value as SueldoVacio<T>;

  @override
  $Res call({
    Object? valorErroneo = freezed,
  }) {
    return _then(SueldoVacio<T>(
      valorErroneo: valorErroneo == freezed
          ? _value.valorErroneo
          : valorErroneo // ignore: cast_nullable_to_non_nullable
              as T,
    ));
  }
}

/// @nodoc

class _$SueldoVacio<T> implements SueldoVacio<T> {
  const _$SueldoVacio({required this.valorErroneo});

  @override
  final T valorErroneo;

  @override
  String toString() {
    return 'ValorErroneo<$T>.sueldoVacio(valorErroneo: $valorErroneo)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is SueldoVacio<T> &&
            (identical(other.valorErroneo, valorErroneo) ||
                const DeepCollectionEquality()
                    .equals(other.valorErroneo, valorErroneo)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(valorErroneo);

  @JsonKey(ignore: true)
  @override
  $SueldoVacioCopyWith<T, SueldoVacio<T>> get copyWith =>
      _$SueldoVacioCopyWithImpl<T, SueldoVacio<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(T valorErroneo) emailInvalido,
    required TResult Function(T valorErroneo) contrasenaCorta,
    required TResult Function(T valorErroneo) stringVacio,
    required TResult Function(T valorErroneo, int min, int max)
        longitudInvalida,
    required TResult Function(T valorErroneo, double max) sueldoInvalido,
    required TResult Function(T valorErroneo) sueldoVacio,
    required TResult Function(T fechaErronea) fechaNula,
    required TResult Function(T numVacantesInvalido) numVacantesInvalido,
    required TResult Function(T valorErroneo) numVacantesNoVacia,
    required TResult Function(T valorErroneo, List<String> turnosValidos)
        turnoInvalido,
    required TResult Function(T valorErroneo, List<String> generosValidos)
        generoInvalido,
  }) {
    return sueldoVacio(valorErroneo);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(T valorErroneo)? emailInvalido,
    TResult Function(T valorErroneo)? contrasenaCorta,
    TResult Function(T valorErroneo)? stringVacio,
    TResult Function(T valorErroneo, int min, int max)? longitudInvalida,
    TResult Function(T valorErroneo, double max)? sueldoInvalido,
    TResult Function(T valorErroneo)? sueldoVacio,
    TResult Function(T fechaErronea)? fechaNula,
    TResult Function(T numVacantesInvalido)? numVacantesInvalido,
    TResult Function(T valorErroneo)? numVacantesNoVacia,
    TResult Function(T valorErroneo, List<String> turnosValidos)? turnoInvalido,
    TResult Function(T valorErroneo, List<String> generosValidos)?
        generoInvalido,
    required TResult orElse(),
  }) {
    if (sueldoVacio != null) {
      return sueldoVacio(valorErroneo);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(EmailInvalido<T> value) emailInvalido,
    required TResult Function(ContrasenaCorta<T> value) contrasenaCorta,
    required TResult Function(StringVacio<T> value) stringVacio,
    required TResult Function(LongitudInvalida<T> value) longitudInvalida,
    required TResult Function(SueldoInvalida<T> value) sueldoInvalido,
    required TResult Function(SueldoVacio<T> value) sueldoVacio,
    required TResult Function(FechaNula<T> value) fechaNula,
    required TResult Function(NumVacantesInvalido<T> value) numVacantesInvalido,
    required TResult Function(NumVacantesNoVacia<T> value) numVacantesNoVacia,
    required TResult Function(TurnoInvalido<T> value) turnoInvalido,
    required TResult Function(GeneroInvalido<T> value) generoInvalido,
  }) {
    return sueldoVacio(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(EmailInvalido<T> value)? emailInvalido,
    TResult Function(ContrasenaCorta<T> value)? contrasenaCorta,
    TResult Function(StringVacio<T> value)? stringVacio,
    TResult Function(LongitudInvalida<T> value)? longitudInvalida,
    TResult Function(SueldoInvalida<T> value)? sueldoInvalido,
    TResult Function(SueldoVacio<T> value)? sueldoVacio,
    TResult Function(FechaNula<T> value)? fechaNula,
    TResult Function(NumVacantesInvalido<T> value)? numVacantesInvalido,
    TResult Function(NumVacantesNoVacia<T> value)? numVacantesNoVacia,
    TResult Function(TurnoInvalido<T> value)? turnoInvalido,
    TResult Function(GeneroInvalido<T> value)? generoInvalido,
    required TResult orElse(),
  }) {
    if (sueldoVacio != null) {
      return sueldoVacio(this);
    }
    return orElse();
  }
}

abstract class SueldoVacio<T> implements ValorErroneo<T> {
  const factory SueldoVacio({required T valorErroneo}) = _$SueldoVacio<T>;

  T get valorErroneo => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $SueldoVacioCopyWith<T, SueldoVacio<T>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $FechaNulaCopyWith<T, $Res> {
  factory $FechaNulaCopyWith(
          FechaNula<T> value, $Res Function(FechaNula<T>) then) =
      _$FechaNulaCopyWithImpl<T, $Res>;
  $Res call({T fechaErronea});
}

/// @nodoc
class _$FechaNulaCopyWithImpl<T, $Res>
    extends _$ValorErroneoCopyWithImpl<T, $Res>
    implements $FechaNulaCopyWith<T, $Res> {
  _$FechaNulaCopyWithImpl(
      FechaNula<T> _value, $Res Function(FechaNula<T>) _then)
      : super(_value, (v) => _then(v as FechaNula<T>));

  @override
  FechaNula<T> get _value => super._value as FechaNula<T>;

  @override
  $Res call({
    Object? fechaErronea = freezed,
  }) {
    return _then(FechaNula<T>(
      fechaErronea: fechaErronea == freezed
          ? _value.fechaErronea
          : fechaErronea // ignore: cast_nullable_to_non_nullable
              as T,
    ));
  }
}

/// @nodoc

class _$FechaNula<T> implements FechaNula<T> {
  const _$FechaNula({required this.fechaErronea});

  @override
  final T fechaErronea;

  @override
  String toString() {
    return 'ValorErroneo<$T>.fechaNula(fechaErronea: $fechaErronea)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is FechaNula<T> &&
            (identical(other.fechaErronea, fechaErronea) ||
                const DeepCollectionEquality()
                    .equals(other.fechaErronea, fechaErronea)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(fechaErronea);

  @JsonKey(ignore: true)
  @override
  $FechaNulaCopyWith<T, FechaNula<T>> get copyWith =>
      _$FechaNulaCopyWithImpl<T, FechaNula<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(T valorErroneo) emailInvalido,
    required TResult Function(T valorErroneo) contrasenaCorta,
    required TResult Function(T valorErroneo) stringVacio,
    required TResult Function(T valorErroneo, int min, int max)
        longitudInvalida,
    required TResult Function(T valorErroneo, double max) sueldoInvalido,
    required TResult Function(T valorErroneo) sueldoVacio,
    required TResult Function(T fechaErronea) fechaNula,
    required TResult Function(T numVacantesInvalido) numVacantesInvalido,
    required TResult Function(T valorErroneo) numVacantesNoVacia,
    required TResult Function(T valorErroneo, List<String> turnosValidos)
        turnoInvalido,
    required TResult Function(T valorErroneo, List<String> generosValidos)
        generoInvalido,
  }) {
    return fechaNula(fechaErronea);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(T valorErroneo)? emailInvalido,
    TResult Function(T valorErroneo)? contrasenaCorta,
    TResult Function(T valorErroneo)? stringVacio,
    TResult Function(T valorErroneo, int min, int max)? longitudInvalida,
    TResult Function(T valorErroneo, double max)? sueldoInvalido,
    TResult Function(T valorErroneo)? sueldoVacio,
    TResult Function(T fechaErronea)? fechaNula,
    TResult Function(T numVacantesInvalido)? numVacantesInvalido,
    TResult Function(T valorErroneo)? numVacantesNoVacia,
    TResult Function(T valorErroneo, List<String> turnosValidos)? turnoInvalido,
    TResult Function(T valorErroneo, List<String> generosValidos)?
        generoInvalido,
    required TResult orElse(),
  }) {
    if (fechaNula != null) {
      return fechaNula(fechaErronea);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(EmailInvalido<T> value) emailInvalido,
    required TResult Function(ContrasenaCorta<T> value) contrasenaCorta,
    required TResult Function(StringVacio<T> value) stringVacio,
    required TResult Function(LongitudInvalida<T> value) longitudInvalida,
    required TResult Function(SueldoInvalida<T> value) sueldoInvalido,
    required TResult Function(SueldoVacio<T> value) sueldoVacio,
    required TResult Function(FechaNula<T> value) fechaNula,
    required TResult Function(NumVacantesInvalido<T> value) numVacantesInvalido,
    required TResult Function(NumVacantesNoVacia<T> value) numVacantesNoVacia,
    required TResult Function(TurnoInvalido<T> value) turnoInvalido,
    required TResult Function(GeneroInvalido<T> value) generoInvalido,
  }) {
    return fechaNula(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(EmailInvalido<T> value)? emailInvalido,
    TResult Function(ContrasenaCorta<T> value)? contrasenaCorta,
    TResult Function(StringVacio<T> value)? stringVacio,
    TResult Function(LongitudInvalida<T> value)? longitudInvalida,
    TResult Function(SueldoInvalida<T> value)? sueldoInvalido,
    TResult Function(SueldoVacio<T> value)? sueldoVacio,
    TResult Function(FechaNula<T> value)? fechaNula,
    TResult Function(NumVacantesInvalido<T> value)? numVacantesInvalido,
    TResult Function(NumVacantesNoVacia<T> value)? numVacantesNoVacia,
    TResult Function(TurnoInvalido<T> value)? turnoInvalido,
    TResult Function(GeneroInvalido<T> value)? generoInvalido,
    required TResult orElse(),
  }) {
    if (fechaNula != null) {
      return fechaNula(this);
    }
    return orElse();
  }
}

abstract class FechaNula<T> implements ValorErroneo<T> {
  const factory FechaNula({required T fechaErronea}) = _$FechaNula<T>;

  T get fechaErronea => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $FechaNulaCopyWith<T, FechaNula<T>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $NumVacantesInvalidoCopyWith<T, $Res> {
  factory $NumVacantesInvalidoCopyWith(NumVacantesInvalido<T> value,
          $Res Function(NumVacantesInvalido<T>) then) =
      _$NumVacantesInvalidoCopyWithImpl<T, $Res>;
  $Res call({T numVacantesInvalido});
}

/// @nodoc
class _$NumVacantesInvalidoCopyWithImpl<T, $Res>
    extends _$ValorErroneoCopyWithImpl<T, $Res>
    implements $NumVacantesInvalidoCopyWith<T, $Res> {
  _$NumVacantesInvalidoCopyWithImpl(NumVacantesInvalido<T> _value,
      $Res Function(NumVacantesInvalido<T>) _then)
      : super(_value, (v) => _then(v as NumVacantesInvalido<T>));

  @override
  NumVacantesInvalido<T> get _value => super._value as NumVacantesInvalido<T>;

  @override
  $Res call({
    Object? numVacantesInvalido = freezed,
  }) {
    return _then(NumVacantesInvalido<T>(
      numVacantesInvalido: numVacantesInvalido == freezed
          ? _value.numVacantesInvalido
          : numVacantesInvalido // ignore: cast_nullable_to_non_nullable
              as T,
    ));
  }
}

/// @nodoc

class _$NumVacantesInvalido<T> implements NumVacantesInvalido<T> {
  const _$NumVacantesInvalido({required this.numVacantesInvalido});

  @override
  final T numVacantesInvalido;

  @override
  String toString() {
    return 'ValorErroneo<$T>.numVacantesInvalido(numVacantesInvalido: $numVacantesInvalido)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is NumVacantesInvalido<T> &&
            (identical(other.numVacantesInvalido, numVacantesInvalido) ||
                const DeepCollectionEquality()
                    .equals(other.numVacantesInvalido, numVacantesInvalido)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(numVacantesInvalido);

  @JsonKey(ignore: true)
  @override
  $NumVacantesInvalidoCopyWith<T, NumVacantesInvalido<T>> get copyWith =>
      _$NumVacantesInvalidoCopyWithImpl<T, NumVacantesInvalido<T>>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(T valorErroneo) emailInvalido,
    required TResult Function(T valorErroneo) contrasenaCorta,
    required TResult Function(T valorErroneo) stringVacio,
    required TResult Function(T valorErroneo, int min, int max)
        longitudInvalida,
    required TResult Function(T valorErroneo, double max) sueldoInvalido,
    required TResult Function(T valorErroneo) sueldoVacio,
    required TResult Function(T fechaErronea) fechaNula,
    required TResult Function(T numVacantesInvalido) numVacantesInvalido,
    required TResult Function(T valorErroneo) numVacantesNoVacia,
    required TResult Function(T valorErroneo, List<String> turnosValidos)
        turnoInvalido,
    required TResult Function(T valorErroneo, List<String> generosValidos)
        generoInvalido,
  }) {
    return numVacantesInvalido(this.numVacantesInvalido);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(T valorErroneo)? emailInvalido,
    TResult Function(T valorErroneo)? contrasenaCorta,
    TResult Function(T valorErroneo)? stringVacio,
    TResult Function(T valorErroneo, int min, int max)? longitudInvalida,
    TResult Function(T valorErroneo, double max)? sueldoInvalido,
    TResult Function(T valorErroneo)? sueldoVacio,
    TResult Function(T fechaErronea)? fechaNula,
    TResult Function(T numVacantesInvalido)? numVacantesInvalido,
    TResult Function(T valorErroneo)? numVacantesNoVacia,
    TResult Function(T valorErroneo, List<String> turnosValidos)? turnoInvalido,
    TResult Function(T valorErroneo, List<String> generosValidos)?
        generoInvalido,
    required TResult orElse(),
  }) {
    if (numVacantesInvalido != null) {
      return numVacantesInvalido(this.numVacantesInvalido);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(EmailInvalido<T> value) emailInvalido,
    required TResult Function(ContrasenaCorta<T> value) contrasenaCorta,
    required TResult Function(StringVacio<T> value) stringVacio,
    required TResult Function(LongitudInvalida<T> value) longitudInvalida,
    required TResult Function(SueldoInvalida<T> value) sueldoInvalido,
    required TResult Function(SueldoVacio<T> value) sueldoVacio,
    required TResult Function(FechaNula<T> value) fechaNula,
    required TResult Function(NumVacantesInvalido<T> value) numVacantesInvalido,
    required TResult Function(NumVacantesNoVacia<T> value) numVacantesNoVacia,
    required TResult Function(TurnoInvalido<T> value) turnoInvalido,
    required TResult Function(GeneroInvalido<T> value) generoInvalido,
  }) {
    return numVacantesInvalido(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(EmailInvalido<T> value)? emailInvalido,
    TResult Function(ContrasenaCorta<T> value)? contrasenaCorta,
    TResult Function(StringVacio<T> value)? stringVacio,
    TResult Function(LongitudInvalida<T> value)? longitudInvalida,
    TResult Function(SueldoInvalida<T> value)? sueldoInvalido,
    TResult Function(SueldoVacio<T> value)? sueldoVacio,
    TResult Function(FechaNula<T> value)? fechaNula,
    TResult Function(NumVacantesInvalido<T> value)? numVacantesInvalido,
    TResult Function(NumVacantesNoVacia<T> value)? numVacantesNoVacia,
    TResult Function(TurnoInvalido<T> value)? turnoInvalido,
    TResult Function(GeneroInvalido<T> value)? generoInvalido,
    required TResult orElse(),
  }) {
    if (numVacantesInvalido != null) {
      return numVacantesInvalido(this);
    }
    return orElse();
  }
}

abstract class NumVacantesInvalido<T> implements ValorErroneo<T> {
  const factory NumVacantesInvalido({required T numVacantesInvalido}) =
      _$NumVacantesInvalido<T>;

  T get numVacantesInvalido => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $NumVacantesInvalidoCopyWith<T, NumVacantesInvalido<T>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $NumVacantesNoVaciaCopyWith<T, $Res> {
  factory $NumVacantesNoVaciaCopyWith(NumVacantesNoVacia<T> value,
          $Res Function(NumVacantesNoVacia<T>) then) =
      _$NumVacantesNoVaciaCopyWithImpl<T, $Res>;
  $Res call({T valorErroneo});
}

/// @nodoc
class _$NumVacantesNoVaciaCopyWithImpl<T, $Res>
    extends _$ValorErroneoCopyWithImpl<T, $Res>
    implements $NumVacantesNoVaciaCopyWith<T, $Res> {
  _$NumVacantesNoVaciaCopyWithImpl(
      NumVacantesNoVacia<T> _value, $Res Function(NumVacantesNoVacia<T>) _then)
      : super(_value, (v) => _then(v as NumVacantesNoVacia<T>));

  @override
  NumVacantesNoVacia<T> get _value => super._value as NumVacantesNoVacia<T>;

  @override
  $Res call({
    Object? valorErroneo = freezed,
  }) {
    return _then(NumVacantesNoVacia<T>(
      valorErroneo: valorErroneo == freezed
          ? _value.valorErroneo
          : valorErroneo // ignore: cast_nullable_to_non_nullable
              as T,
    ));
  }
}

/// @nodoc

class _$NumVacantesNoVacia<T> implements NumVacantesNoVacia<T> {
  const _$NumVacantesNoVacia({required this.valorErroneo});

  @override
  final T valorErroneo;

  @override
  String toString() {
    return 'ValorErroneo<$T>.numVacantesNoVacia(valorErroneo: $valorErroneo)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is NumVacantesNoVacia<T> &&
            (identical(other.valorErroneo, valorErroneo) ||
                const DeepCollectionEquality()
                    .equals(other.valorErroneo, valorErroneo)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(valorErroneo);

  @JsonKey(ignore: true)
  @override
  $NumVacantesNoVaciaCopyWith<T, NumVacantesNoVacia<T>> get copyWith =>
      _$NumVacantesNoVaciaCopyWithImpl<T, NumVacantesNoVacia<T>>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(T valorErroneo) emailInvalido,
    required TResult Function(T valorErroneo) contrasenaCorta,
    required TResult Function(T valorErroneo) stringVacio,
    required TResult Function(T valorErroneo, int min, int max)
        longitudInvalida,
    required TResult Function(T valorErroneo, double max) sueldoInvalido,
    required TResult Function(T valorErroneo) sueldoVacio,
    required TResult Function(T fechaErronea) fechaNula,
    required TResult Function(T numVacantesInvalido) numVacantesInvalido,
    required TResult Function(T valorErroneo) numVacantesNoVacia,
    required TResult Function(T valorErroneo, List<String> turnosValidos)
        turnoInvalido,
    required TResult Function(T valorErroneo, List<String> generosValidos)
        generoInvalido,
  }) {
    return numVacantesNoVacia(valorErroneo);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(T valorErroneo)? emailInvalido,
    TResult Function(T valorErroneo)? contrasenaCorta,
    TResult Function(T valorErroneo)? stringVacio,
    TResult Function(T valorErroneo, int min, int max)? longitudInvalida,
    TResult Function(T valorErroneo, double max)? sueldoInvalido,
    TResult Function(T valorErroneo)? sueldoVacio,
    TResult Function(T fechaErronea)? fechaNula,
    TResult Function(T numVacantesInvalido)? numVacantesInvalido,
    TResult Function(T valorErroneo)? numVacantesNoVacia,
    TResult Function(T valorErroneo, List<String> turnosValidos)? turnoInvalido,
    TResult Function(T valorErroneo, List<String> generosValidos)?
        generoInvalido,
    required TResult orElse(),
  }) {
    if (numVacantesNoVacia != null) {
      return numVacantesNoVacia(valorErroneo);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(EmailInvalido<T> value) emailInvalido,
    required TResult Function(ContrasenaCorta<T> value) contrasenaCorta,
    required TResult Function(StringVacio<T> value) stringVacio,
    required TResult Function(LongitudInvalida<T> value) longitudInvalida,
    required TResult Function(SueldoInvalida<T> value) sueldoInvalido,
    required TResult Function(SueldoVacio<T> value) sueldoVacio,
    required TResult Function(FechaNula<T> value) fechaNula,
    required TResult Function(NumVacantesInvalido<T> value) numVacantesInvalido,
    required TResult Function(NumVacantesNoVacia<T> value) numVacantesNoVacia,
    required TResult Function(TurnoInvalido<T> value) turnoInvalido,
    required TResult Function(GeneroInvalido<T> value) generoInvalido,
  }) {
    return numVacantesNoVacia(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(EmailInvalido<T> value)? emailInvalido,
    TResult Function(ContrasenaCorta<T> value)? contrasenaCorta,
    TResult Function(StringVacio<T> value)? stringVacio,
    TResult Function(LongitudInvalida<T> value)? longitudInvalida,
    TResult Function(SueldoInvalida<T> value)? sueldoInvalido,
    TResult Function(SueldoVacio<T> value)? sueldoVacio,
    TResult Function(FechaNula<T> value)? fechaNula,
    TResult Function(NumVacantesInvalido<T> value)? numVacantesInvalido,
    TResult Function(NumVacantesNoVacia<T> value)? numVacantesNoVacia,
    TResult Function(TurnoInvalido<T> value)? turnoInvalido,
    TResult Function(GeneroInvalido<T> value)? generoInvalido,
    required TResult orElse(),
  }) {
    if (numVacantesNoVacia != null) {
      return numVacantesNoVacia(this);
    }
    return orElse();
  }
}

abstract class NumVacantesNoVacia<T> implements ValorErroneo<T> {
  const factory NumVacantesNoVacia({required T valorErroneo}) =
      _$NumVacantesNoVacia<T>;

  T get valorErroneo => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $NumVacantesNoVaciaCopyWith<T, NumVacantesNoVacia<T>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $TurnoInvalidoCopyWith<T, $Res> {
  factory $TurnoInvalidoCopyWith(
          TurnoInvalido<T> value, $Res Function(TurnoInvalido<T>) then) =
      _$TurnoInvalidoCopyWithImpl<T, $Res>;
  $Res call({T valorErroneo, List<String> turnosValidos});
}

/// @nodoc
class _$TurnoInvalidoCopyWithImpl<T, $Res>
    extends _$ValorErroneoCopyWithImpl<T, $Res>
    implements $TurnoInvalidoCopyWith<T, $Res> {
  _$TurnoInvalidoCopyWithImpl(
      TurnoInvalido<T> _value, $Res Function(TurnoInvalido<T>) _then)
      : super(_value, (v) => _then(v as TurnoInvalido<T>));

  @override
  TurnoInvalido<T> get _value => super._value as TurnoInvalido<T>;

  @override
  $Res call({
    Object? valorErroneo = freezed,
    Object? turnosValidos = freezed,
  }) {
    return _then(TurnoInvalido<T>(
      valorErroneo: valorErroneo == freezed
          ? _value.valorErroneo
          : valorErroneo // ignore: cast_nullable_to_non_nullable
              as T,
      turnosValidos: turnosValidos == freezed
          ? _value.turnosValidos
          : turnosValidos // ignore: cast_nullable_to_non_nullable
              as List<String>,
    ));
  }
}

/// @nodoc

class _$TurnoInvalido<T> implements TurnoInvalido<T> {
  const _$TurnoInvalido(
      {required this.valorErroneo, required this.turnosValidos});

  @override
  final T valorErroneo;
  @override
  final List<String> turnosValidos;

  @override
  String toString() {
    return 'ValorErroneo<$T>.turnoInvalido(valorErroneo: $valorErroneo, turnosValidos: $turnosValidos)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is TurnoInvalido<T> &&
            (identical(other.valorErroneo, valorErroneo) ||
                const DeepCollectionEquality()
                    .equals(other.valorErroneo, valorErroneo)) &&
            (identical(other.turnosValidos, turnosValidos) ||
                const DeepCollectionEquality()
                    .equals(other.turnosValidos, turnosValidos)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(valorErroneo) ^
      const DeepCollectionEquality().hash(turnosValidos);

  @JsonKey(ignore: true)
  @override
  $TurnoInvalidoCopyWith<T, TurnoInvalido<T>> get copyWith =>
      _$TurnoInvalidoCopyWithImpl<T, TurnoInvalido<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(T valorErroneo) emailInvalido,
    required TResult Function(T valorErroneo) contrasenaCorta,
    required TResult Function(T valorErroneo) stringVacio,
    required TResult Function(T valorErroneo, int min, int max)
        longitudInvalida,
    required TResult Function(T valorErroneo, double max) sueldoInvalido,
    required TResult Function(T valorErroneo) sueldoVacio,
    required TResult Function(T fechaErronea) fechaNula,
    required TResult Function(T numVacantesInvalido) numVacantesInvalido,
    required TResult Function(T valorErroneo) numVacantesNoVacia,
    required TResult Function(T valorErroneo, List<String> turnosValidos)
        turnoInvalido,
    required TResult Function(T valorErroneo, List<String> generosValidos)
        generoInvalido,
  }) {
    return turnoInvalido(valorErroneo, turnosValidos);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(T valorErroneo)? emailInvalido,
    TResult Function(T valorErroneo)? contrasenaCorta,
    TResult Function(T valorErroneo)? stringVacio,
    TResult Function(T valorErroneo, int min, int max)? longitudInvalida,
    TResult Function(T valorErroneo, double max)? sueldoInvalido,
    TResult Function(T valorErroneo)? sueldoVacio,
    TResult Function(T fechaErronea)? fechaNula,
    TResult Function(T numVacantesInvalido)? numVacantesInvalido,
    TResult Function(T valorErroneo)? numVacantesNoVacia,
    TResult Function(T valorErroneo, List<String> turnosValidos)? turnoInvalido,
    TResult Function(T valorErroneo, List<String> generosValidos)?
        generoInvalido,
    required TResult orElse(),
  }) {
    if (turnoInvalido != null) {
      return turnoInvalido(valorErroneo, turnosValidos);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(EmailInvalido<T> value) emailInvalido,
    required TResult Function(ContrasenaCorta<T> value) contrasenaCorta,
    required TResult Function(StringVacio<T> value) stringVacio,
    required TResult Function(LongitudInvalida<T> value) longitudInvalida,
    required TResult Function(SueldoInvalida<T> value) sueldoInvalido,
    required TResult Function(SueldoVacio<T> value) sueldoVacio,
    required TResult Function(FechaNula<T> value) fechaNula,
    required TResult Function(NumVacantesInvalido<T> value) numVacantesInvalido,
    required TResult Function(NumVacantesNoVacia<T> value) numVacantesNoVacia,
    required TResult Function(TurnoInvalido<T> value) turnoInvalido,
    required TResult Function(GeneroInvalido<T> value) generoInvalido,
  }) {
    return turnoInvalido(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(EmailInvalido<T> value)? emailInvalido,
    TResult Function(ContrasenaCorta<T> value)? contrasenaCorta,
    TResult Function(StringVacio<T> value)? stringVacio,
    TResult Function(LongitudInvalida<T> value)? longitudInvalida,
    TResult Function(SueldoInvalida<T> value)? sueldoInvalido,
    TResult Function(SueldoVacio<T> value)? sueldoVacio,
    TResult Function(FechaNula<T> value)? fechaNula,
    TResult Function(NumVacantesInvalido<T> value)? numVacantesInvalido,
    TResult Function(NumVacantesNoVacia<T> value)? numVacantesNoVacia,
    TResult Function(TurnoInvalido<T> value)? turnoInvalido,
    TResult Function(GeneroInvalido<T> value)? generoInvalido,
    required TResult orElse(),
  }) {
    if (turnoInvalido != null) {
      return turnoInvalido(this);
    }
    return orElse();
  }
}

abstract class TurnoInvalido<T> implements ValorErroneo<T> {
  const factory TurnoInvalido(
      {required T valorErroneo,
      required List<String> turnosValidos}) = _$TurnoInvalido<T>;

  T get valorErroneo => throw _privateConstructorUsedError;
  List<String> get turnosValidos => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $TurnoInvalidoCopyWith<T, TurnoInvalido<T>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $GeneroInvalidoCopyWith<T, $Res> {
  factory $GeneroInvalidoCopyWith(
          GeneroInvalido<T> value, $Res Function(GeneroInvalido<T>) then) =
      _$GeneroInvalidoCopyWithImpl<T, $Res>;
  $Res call({T valorErroneo, List<String> generosValidos});
}

/// @nodoc
class _$GeneroInvalidoCopyWithImpl<T, $Res>
    extends _$ValorErroneoCopyWithImpl<T, $Res>
    implements $GeneroInvalidoCopyWith<T, $Res> {
  _$GeneroInvalidoCopyWithImpl(
      GeneroInvalido<T> _value, $Res Function(GeneroInvalido<T>) _then)
      : super(_value, (v) => _then(v as GeneroInvalido<T>));

  @override
  GeneroInvalido<T> get _value => super._value as GeneroInvalido<T>;

  @override
  $Res call({
    Object? valorErroneo = freezed,
    Object? generosValidos = freezed,
  }) {
    return _then(GeneroInvalido<T>(
      valorErroneo: valorErroneo == freezed
          ? _value.valorErroneo
          : valorErroneo // ignore: cast_nullable_to_non_nullable
              as T,
      generosValidos: generosValidos == freezed
          ? _value.generosValidos
          : generosValidos // ignore: cast_nullable_to_non_nullable
              as List<String>,
    ));
  }
}

/// @nodoc

class _$GeneroInvalido<T> implements GeneroInvalido<T> {
  const _$GeneroInvalido(
      {required this.valorErroneo, required this.generosValidos});

  @override
  final T valorErroneo;
  @override
  final List<String> generosValidos;

  @override
  String toString() {
    return 'ValorErroneo<$T>.generoInvalido(valorErroneo: $valorErroneo, generosValidos: $generosValidos)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is GeneroInvalido<T> &&
            (identical(other.valorErroneo, valorErroneo) ||
                const DeepCollectionEquality()
                    .equals(other.valorErroneo, valorErroneo)) &&
            (identical(other.generosValidos, generosValidos) ||
                const DeepCollectionEquality()
                    .equals(other.generosValidos, generosValidos)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(valorErroneo) ^
      const DeepCollectionEquality().hash(generosValidos);

  @JsonKey(ignore: true)
  @override
  $GeneroInvalidoCopyWith<T, GeneroInvalido<T>> get copyWith =>
      _$GeneroInvalidoCopyWithImpl<T, GeneroInvalido<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(T valorErroneo) emailInvalido,
    required TResult Function(T valorErroneo) contrasenaCorta,
    required TResult Function(T valorErroneo) stringVacio,
    required TResult Function(T valorErroneo, int min, int max)
        longitudInvalida,
    required TResult Function(T valorErroneo, double max) sueldoInvalido,
    required TResult Function(T valorErroneo) sueldoVacio,
    required TResult Function(T fechaErronea) fechaNula,
    required TResult Function(T numVacantesInvalido) numVacantesInvalido,
    required TResult Function(T valorErroneo) numVacantesNoVacia,
    required TResult Function(T valorErroneo, List<String> turnosValidos)
        turnoInvalido,
    required TResult Function(T valorErroneo, List<String> generosValidos)
        generoInvalido,
  }) {
    return generoInvalido(valorErroneo, generosValidos);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(T valorErroneo)? emailInvalido,
    TResult Function(T valorErroneo)? contrasenaCorta,
    TResult Function(T valorErroneo)? stringVacio,
    TResult Function(T valorErroneo, int min, int max)? longitudInvalida,
    TResult Function(T valorErroneo, double max)? sueldoInvalido,
    TResult Function(T valorErroneo)? sueldoVacio,
    TResult Function(T fechaErronea)? fechaNula,
    TResult Function(T numVacantesInvalido)? numVacantesInvalido,
    TResult Function(T valorErroneo)? numVacantesNoVacia,
    TResult Function(T valorErroneo, List<String> turnosValidos)? turnoInvalido,
    TResult Function(T valorErroneo, List<String> generosValidos)?
        generoInvalido,
    required TResult orElse(),
  }) {
    if (generoInvalido != null) {
      return generoInvalido(valorErroneo, generosValidos);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(EmailInvalido<T> value) emailInvalido,
    required TResult Function(ContrasenaCorta<T> value) contrasenaCorta,
    required TResult Function(StringVacio<T> value) stringVacio,
    required TResult Function(LongitudInvalida<T> value) longitudInvalida,
    required TResult Function(SueldoInvalida<T> value) sueldoInvalido,
    required TResult Function(SueldoVacio<T> value) sueldoVacio,
    required TResult Function(FechaNula<T> value) fechaNula,
    required TResult Function(NumVacantesInvalido<T> value) numVacantesInvalido,
    required TResult Function(NumVacantesNoVacia<T> value) numVacantesNoVacia,
    required TResult Function(TurnoInvalido<T> value) turnoInvalido,
    required TResult Function(GeneroInvalido<T> value) generoInvalido,
  }) {
    return generoInvalido(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(EmailInvalido<T> value)? emailInvalido,
    TResult Function(ContrasenaCorta<T> value)? contrasenaCorta,
    TResult Function(StringVacio<T> value)? stringVacio,
    TResult Function(LongitudInvalida<T> value)? longitudInvalida,
    TResult Function(SueldoInvalida<T> value)? sueldoInvalido,
    TResult Function(SueldoVacio<T> value)? sueldoVacio,
    TResult Function(FechaNula<T> value)? fechaNula,
    TResult Function(NumVacantesInvalido<T> value)? numVacantesInvalido,
    TResult Function(NumVacantesNoVacia<T> value)? numVacantesNoVacia,
    TResult Function(TurnoInvalido<T> value)? turnoInvalido,
    TResult Function(GeneroInvalido<T> value)? generoInvalido,
    required TResult orElse(),
  }) {
    if (generoInvalido != null) {
      return generoInvalido(this);
    }
    return orElse();
  }
}

abstract class GeneroInvalido<T> implements ValorErroneo<T> {
  const factory GeneroInvalido(
      {required T valorErroneo,
      required List<String> generosValidos}) = _$GeneroInvalido<T>;

  T get valorErroneo => throw _privateConstructorUsedError;
  List<String> get generosValidos => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $GeneroInvalidoCopyWith<T, GeneroInvalido<T>> get copyWith =>
      throw _privateConstructorUsedError;
}
